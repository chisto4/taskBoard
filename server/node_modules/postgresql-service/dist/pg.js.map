{"version":3,"sources":["../src/pg.ts"],"names":["Pool","types","pg","parse","parseConnectionURL","pgConnectionString","setTypeParser","str","Date","replace","DEFAULT_ENV","DEFAULT_PG_URL_ENV_NAME","initPGService","PG_URL_ENV_NAME","ENV","PG","log","noop","config","pool","query","queries","transaction","errorPromise","Promise","resolve","reject","once","err","castedError","YError","wrap","stack","service","dispose","end","client","connect","results","all","map","index","castPGQueryError","text","values","cast","code","params","release","args","undefined","name","severity","detail","schema","table","column","dataType","constraint","file","line","routine"],"mappings":"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","sourcesContent":["import { singleton, provider, autoInject } from 'knifecycle';\nimport YError from 'yerror';\nimport pgConnectionString from 'pg-connection-string';\nimport pg from 'pg';\nimport type { PoolConfig, QueryResult } from 'pg';\nimport type { LogService } from 'common-services';\n\n// Required to work as a MJS module. Will be turnable\n// into real imports when those module will support MJS\nconst { Pool, types } = pg;\nconst { parse: parseConnectionURL } = pgConnectionString;\n\n/* Architecture Note #1.2: Timezones\n\nEnsure not messing with time zones with practical defaults.\nSee https://github.com/vitaly-t/pg-promise/issues/389\n\n// TODO: Ensure arrays are well parsed too with `postgres-array` for\n// 1115 - timestamp without time zone[]\n// 1182 - date[]\n*/\n\ntypes.setTypeParser(1114, (str) =>\n  str === null ? null : new Date(str.replace(' ', 'T') + 'Z'),\n);\ntypes.setTypeParser(1082, (str) =>\n  str === null ? null : new Date(str + 'T00:00:00Z'),\n);\n\nconst DEFAULT_ENV: PG_ENV = {};\n\nexport const DEFAULT_PG_URL_ENV_NAME = 'PG_URL';\n\ntype PG_CONFIG = PoolConfig;\ntype SQLValue = any;\n\nexport type PG_ENV = {\n  PG_URL?: string;\n  [name: string]: string;\n};\n\nexport type PGServiceConfig = {\n  PG_URL_ENV_NAME?: string;\n  ENV?: PG_ENV;\n  PG: PG_CONFIG;\n};\n\nexport type PGServiceDependencies = PGServiceConfig & {\n  log?: LogService;\n};\n\nexport type PGQuery = {\n  text: string;\n  values: SQLValue[];\n};\n\nexport interface PGService {\n  query: (query: PGQuery) => Promise<QueryResult>;\n  queries: (queries: PGQuery[]) => Promise<QueryResult[]>;\n  transaction: (queries: PGQuery[]) => Promise<QueryResult[]>;\n}\n\nexport interface PGProvider {\n  service: PGService;\n  errorPromise: Promise<void>;\n  dispose: () => Promise<void>;\n}\n\n/* Architecture Note #1: PostgreSQL service\n\nThis service is a simple wrapper around the `pg` node module\n that adds native support for transsactions and a few tweaks\n for a better plug and play experience.\n\nIts goal is to expose only a subset of its capabilities to\n reduce the API surface to 3 use cases:\n- run a single query\n- run several queries in parallel\n- run several queries into a single transaction\n\nAnd that's it ;). The purpose is to know SQL, not an ORM, and\n have an easily mockable API surface.\n\nPG module API Doc: https://node-postgres.com/features/pooling\n*/\n\nexport default singleton(provider(autoInject(initPGService), 'pg'));\n\n/**\n * Instantiate the pg service\n * @name initPGService\n * @function\n * @param  {Object}   services\n * The services to inject\n * @param  {Function} [services.log]\n * A logging function\n * @param  {Object}   [services.PG_URL_ENV_NAME]\n * The environment variable name in which to pick-up the\n *  PG url\n * @param  {Object}   [services.ENV]\n * An environment object\n * @param  {Object}   services.PG\n * A `pg` compatible configuration object\n * @return {Promise<Object>}\n * A promise of the pg service\n * @example\n * import initPGService from 'postgresql-service';\n *\n * const { service: pg, dispose } = await initPGService({\n *   log: console.log.bind(console),\n *   ENV: process.env, // Proxy the PG_URL env var\n * });\n *\n * const result = pg.query('SELECT 1');\n *\n * await dispose();\n */\nasync function initPGService({\n  PG_URL_ENV_NAME = DEFAULT_PG_URL_ENV_NAME,\n  ENV = DEFAULT_ENV,\n  PG,\n  log = noop,\n}: PGServiceDependencies): Promise<PGProvider> {\n  const config = {\n    ...PG,\n    ...(ENV[PG_URL_ENV_NAME] ? parseConnectionURL(ENV[PG_URL_ENV_NAME]) : {}),\n  };\n  const pool = new Pool(config as PoolConfig);\n  const pg = {\n    query,\n    queries,\n    transaction,\n  };\n  const errorPromise = new Promise<void>((resolve, reject) => {\n    pool.once('error', (err) => {\n      const castedError = YError.wrap(err);\n      log('error', 'Got a PG error:', castedError.stack);\n      reject(castedError);\n    });\n  });\n  log('debug', 'üêò - Initializing PG service...');\n\n  return {\n    service: pg,\n    errorPromise,\n    dispose: async () => {\n      log('debug', 'üêò - Draining PG connections... üêò');\n      await pool.end();\n      log('debug', 'üêò - PG connections drained ! üêò');\n    },\n  };\n\n  /**\n   * Executes the given query\n   * @return {String}   Query to execute\n   * @return {Object}   Arguments hash for the query\n   * @example\n   * const { rows, fields } = await pg.query(\n   *    'SELECT * FROM users WHERE user = $$userId',\n   *    { userId: 1 }\n   * );\n   */\n  async function query(query: PGQuery) {\n    return (await pg.queries([query]))[0];\n  }\n\n  /**\n   * Executes the given queries in parallel (using the connections pool)\n   * @return {Array<String>}   Queries to execute\n   * @return {Object}          Arguments hashes for the queries\n   * @example\n   * const [{ rows, fields }, { rows2, fields2 }] = await pg.queries([\n   *    'SELECT * FROM users WHERE user = $$userId',\n   *    'SELECT * FROM users WHERE user = $$userId',\n   * ], { userId: 1 });\n   */\n  async function queries(queries: PGQuery[]) {\n    const client = await pool.connect();\n    let results;\n\n    try {\n      results = await Promise.all(\n        queries.map(async (query, index) => {\n          try {\n            return await client.query(query);\n          } catch (err) {\n            throw castPGQueryError(err, query.text, query.values, index);\n          }\n        }),\n      );\n    } catch (err) {\n      const castedError = YError.cast(\n        err,\n        'E_PG_QUERIES',\n        queries.map((query) => query.text),\n        queries.map((query) => query.values),\n        err.code === 'E_PG_QUERY'\n          ? err.params && typeof err.params[2] === 'object'\n            ? err.params[2]\n            : {}\n          : {},\n      );\n\n      throw castedError;\n    } finally {\n      await client.release();\n    }\n    return results;\n  }\n\n  /**\n   * Executes the given queries in a single transaction\n   * @return {Array<String>}   Queries to execute\n   * @return {Object}          Arguments hashes for the queries\n   * @example\n   * const [, { rows, fields }] = await pg.transaction([\n   *    'UPDATE users SET isActive = true WHERE user = $$userId',\n   *    'SELECT * FROM users WHERE user = $$userId',\n   * ], { userId: 1 });\n   */\n  async function transaction(queries: PGQuery[]) {\n    const client = await pool.connect();\n    let results;\n\n    try {\n      await client.query('BEGIN');\n      try {\n        results = await Promise.all(\n          queries.map(async (query, index) => {\n            try {\n              return await client.query(query);\n            } catch (err) {\n              throw castPGQueryError(err, query.text, query.values, index);\n            }\n          }),\n        );\n      } catch (err) {\n        const castedError = YError.cast(\n          err,\n          'E_PG_TRANSACTION',\n          queries.map((query) => query.text),\n          queries.map((query) => query.values),\n          err.code === 'E_PG_QUERY'\n            ? err.params && typeof err.params[2] === 'object'\n              ? err.params[2]\n              : {}\n            : {},\n        );\n\n        await client.query('ROLLBACK');\n        throw castedError;\n      }\n      await client.query('COMMIT');\n    } finally {\n      await client.release();\n    }\n\n    return results;\n  }\n}\n\n/* Architecture Note #1.1: Errors casting\n\nThis service also convert `pg` errors into `yerror` ones which taste\n better imo.\n*/\nfunction castPGQueryError(\n  err: Error,\n  query: string,\n  args: any[],\n  index: number,\n) {\n  return YError.wrap(err, 'E_PG_QUERY', query, args, {\n    index,\n    code: (err as any).code || undefined,\n    name: (err as any).name || undefined,\n    severity: (err as any).severity || undefined,\n    detail: (err as any).detail || undefined,\n    schema: (err as any).schema || undefined,\n    table: (err as any).table || undefined,\n    column: (err as any).column || undefined,\n    dataType: (err as any).dataType || undefined,\n    constraint: (err as any).constraint || undefined,\n    file: (err as any).file || undefined,\n    line: (err as any).line || undefined,\n    routine: (err as any).routine || undefined,\n  });\n}\n\nfunction noop(...args: unknown[]): void {\n  args;\n}\n"],"file":"pg.js"}