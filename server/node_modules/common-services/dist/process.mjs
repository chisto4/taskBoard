import YError from 'yerror';
import { provider as _provider, singleton } from 'knifecycle';
const DEFAULT_NODE_ENVS = ['development', 'test', 'production'];
const DEFAULT_SIGNALS = ['SIGTERM', 'SIGINT'];

function noop() {
  return undefined;
}

export default singleton(_provider(initProcess, "process", ["NODE_ENV", "?PROCESS_NAME", "?SIGNALS", "?NODE_ENVS", "?log", "exit", "$instance", "$fatalError"]));

async function initProcess({
  NODE_ENV,
  PROCESS_NAME = '',
  SIGNALS = DEFAULT_SIGNALS,
  NODE_ENVS = DEFAULT_NODE_ENVS,
  log = noop,
  exit,
  $instance,
  $fatalError
}) {
  const signalsListeners = SIGNALS.map(signal => [signal, terminate.bind(null, signal)]);
  let shuttingDown = null;

  if (!NODE_ENVS.includes(NODE_ENV)) {
    throw new YError('E_NODE_ENV', NODE_ENV);
  }

  log('warning', `ðŸ”‚ - Running in "${NODE_ENV}" environment.`);
  global.process.title = (PROCESS_NAME || global.process.title) + ' - ' + NODE_ENV;
  signalsListeners.forEach(([signal, signalListener]) => {
    global.process.on(signal, signalListener);
  });
  $fatalError.promise.catch(err => {
    log('error', 'ðŸ’€ - Fatal error');
    log('stack', err.stack || err);
    terminate('FATAL');
  });
  global.process.on('uncaughtException', catchUncaughtException);

  function catchUncaughtException(err) {
    log('error', 'ðŸ’€ - Uncaught Exception');
    log('stack', err.stack || err);
    terminate('ERR');
  }

  function terminate(signal) {
    if (shuttingDown) {
      log('warning', `ðŸš¦ - ${signal} received again, shutdown now.`);
      exit(1);
    } else {
      log('warning', `ðŸš¦ - ${signal} received. Send it again to kill me instantly.`);
      shutdown(['ERR', 'FATAL'].includes(signal) ? 1 : 0);
    }
  }

  async function shutdown(code) {
    shuttingDown = true;
    log('warning', 'Shutting down now ðŸ™...');
    await $instance.destroy();

    try {
      log('warning', 'ðŸ˜Ž - Gracefull shutdown sucessfully done !');
      exit(code);
    } catch (err) {
      log('error', 'ðŸ¤” - Could not gracefully shutdown.');
      log('stack', err.stack || err);
      exit(code);
    }
  }

  async function dispose() {
    global.process.removeListener('uncaughtException', catchUncaughtException);
    signalsListeners.forEach(([signal, signalListener]) => {
      global.process.removeListener(signal, signalListener);
    });
  }

  log('debug', 'ðŸ“‡ - Process service initialized.');
  return {
    service: global.process,
    dispose
  };
}
//# sourceMappingURL=process.mjs.map