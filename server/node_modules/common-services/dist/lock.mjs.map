{"version":3,"sources":["../src/lock.ts"],"names":["YError","autoService","singleton","noop","undefined","initLock","LOCKS_MAP","Map","LOCK_TIMEOUT","Infinity","delay","log","take","release","key","previousLocks","get","locksLength","length","set","_resolve","releasePromise","Promise","resolve","reject","create","then","newLock","push","actualLocks","shift","delete"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAASC,OAAW,IAAXA,QAAT,EAAsBC,SAAtB,QAAuC,YAAvC;;AAIA,MAAMC,IAAI,GAAG,MAAMC,SAAnB;;AAiCA,eAAeF,SAAS,CAACD,QAAW,CAACI,QAAD,2DAAZ,EAAwB,IAAxB,CAAxB;;AAiDA,eAAeA,QAAf,CAA2B;AACzBC,EAAAA,SAAS,GAAG,IAAIC,GAAJ,EADa;AAEzBC,EAAAA,YAAY,GAAGC,QAFU;AAGzBC,EAAAA,KAHyB;AAIzBC,EAAAA,GAAG,GAAGR;AAJmB,CAA3B,EAKwD;AACtDQ,EAAAA,GAAG,CAAC,OAAD,EAAU,gCAAV,CAAH;AAEA,SAAO;AACLC,IAAAA,IADK;AAELC,IAAAA;AAFK,GAAP;;AAcA,iBAAeD,IAAf,CAAoBE,GAApB,EAAyB;AACvB,UAAMC,aAAa,GAAGT,SAAS,CAACU,GAAV,CAAcF,GAAd,KAAsB,EAA5C;AACA,UAAMG,WAAW,GAAGF,aAAa,CAACG,MAAlC;;AAEA,QAAID,WAAW,KAAK,CAApB,EAAuB;AACrBX,MAAAA,SAAS,CAACa,GAAV,CAAcL,GAAd,EAAmBC,aAAnB;AACD;;AAEDJ,IAAAA,GAAG,CACD,OADC,EAEA,4BAA2BG,GAAI,uBAAsBG,WAAY,GAFjE,CAAH;;AAKA,QAAIG,QAAJ;;AACA,UAAMC,cAA6B,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrEJ,MAAAA,QAAQ,GAAGG,OAAX;;AAEA,UAAIf,YAAY,KAAKC,QAArB,EAA+B;AAC7BC,QAAAA,KAAK,CACFe,MADH,CACUjB,YADV,EAEGkB,IAFH,CAEQ,MAAMF,MAAM,CAAC,IAAIxB,MAAJ,CAAW,gBAAX,CAAD,CAFpB;AAGD;AACF,KARqC,CAAtC;AAUA,UAAM2B,OAAO,GAAG;AACdN,MAAAA,cADc;AAEdR,MAAAA,OAAO,EAAEO;AAFK,KAAhB;AAKAL,IAAAA,aAAa,CAACa,IAAd,CAAmBD,OAAnB;;AAEA,QAAIV,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAMF,aAAa,CAACE,WAAW,GAAG,CAAf,CAAb,CAA+BI,cAArC;AACD;AACF;;AAOD,iBAAeR,OAAf,CAAuBC,GAAvB,EAA4B;AAC1B,UAAMe,WAAW,GAAGvB,SAAS,CAACU,GAAV,CAAcF,GAAd,KAAsB,EAA1C;AACA,UAAMG,WAAW,GAAGY,WAAW,CAACX,MAAhC;;AAEA,QAAI,CAACD,WAAL,EAAkB;AAChB,YAAM,IAAIjB,MAAJ,CAAW,WAAX,EAAwBc,GAAxB,CAAN;AACD;;AAEDH,IAAAA,GAAG,CACD,OADC,EAEA,+BAA8BG,GAAI,uBAAsBG,WAAY,GAFpE,CAAH;AAIAY,IAAAA,WAAW,CAACC,KAAZ,GAAoBjB,OAApB;;AAEA,QAAII,WAAW,KAAK,CAApB,EAAuB;AACrBX,MAAAA,SAAS,CAACyB,MAAV,CAAiBjB,GAAjB;AACD;AACF;AACF","sourcesContent":["import YError from 'yerror';\nimport { autoService, singleton } from 'knifecycle';\nimport type { LogService } from './log';\nimport type { DelayService } from './delay';\n\nconst noop = () => undefined;\n\ninterface Lock {\n  releasePromise: Promise<void>;\n  release: () => void;\n}\n\nexport type LockServiceConfig<K> = {\n  LOCKS_MAP?: Map<K, Lock[]>;\n  LOCK_TIMEOUT?: number;\n};\n\ntype LockServiceDependencies<K> = LockServiceConfig<K> & {\n  log?: LogService;\n  delay: DelayService;\n};\n\nexport interface LockService<K> {\n  take: (key: K) => Promise<void>;\n  release: (key: K) => Promise<void>;\n}\n\n/* Architecture Note #1.8: Lock\n\nThis service allows to maintain a lock on a given resource in order\n to ensure a sequential access to it in asynchronous code.\n\nThe release is done by its key and the current lock is removed. There\n is no check on the fact the lock is well released. By design, it is\n your responsibility to ensure you release the locks properly. That\n said, it should not be hard to handle since the actual behavior of\n the library makes your code run sequentially.\n*/\nexport default singleton(autoService(initLock), true);\n\n/**\n * Instantiate the lock service\n * @name initLock\n * @function\n * @param  {Object}     services\n * The services to inject\n * @param  {Map}   [services.LOCKS_MAP]\n * A map to store le current locks (optional)\n * @param  {Number}   [services.LOCK_TIMEOUT=Infitiny]\n * The timeout in milliseconds for the lock to\n *  be released.\n * @param  {Function}   [services.log]\n * A logging function\n * @param  {Object}   [services.delay]\n * A delay service like the `common-services` one\n * @return {Promise<Object>}\n * A promise of the lock service\n * @example\n * import initLog from 'common-services/dist/log';\n * import initDelayService from 'common-services/dist/delay';\n * import initLock from 'common-services/dist/lock';\n * import ms from 'ms';\n *\n * const log = await initLogService({\n *   logger: require('winston'),\n *   debug: require('debug')('myapp'),\n * });\n * const delay = await initDelayService({ log });\n * const lock = await initLock({ LOCK_TIMEOUT: ms('5s'), delay, log });\n *\n *\n * run();\n *\n * async function run() {\n *   // The following async jobs are done sequentially\n *   // if they have the same `resourceKey` value\n *   await Promise.all(asynTasks.map(async (asyncTask) => {\n *     await lock.take(asyncTask.resourceKey);\n *\n *     await myAsyncStuff1(asyncTask);\n *     await myAsyncStuff2(asyncTask);\n *     await myAsyncStuff3(asyncTask);\n *\n *    lock.release(asyncTask.resourceKey);\n *   });\n * }\n */\nasync function initLock<K>({\n  LOCKS_MAP = new Map(),\n  LOCK_TIMEOUT = Infinity,\n  delay,\n  log = noop,\n}: LockServiceDependencies<K>): Promise<LockService<K>> {\n  log('debug', '🔒 - Lock service initialized.');\n\n  return {\n    take,\n    release,\n  };\n\n  /**\n   * Take the lock on the given resource key\n   * @param  {String}   key\n   * A unique key for the locked resource\n   * @return {Promise}\n   * A promise to be resolved when the lock\n   *  is gained or rejected if the lock release\n   *  timeout is reached.\n   */\n  async function take(key) {\n    const previousLocks = LOCKS_MAP.get(key) || [];\n    const locksLength = previousLocks.length;\n\n    if (locksLength === 0) {\n      LOCKS_MAP.set(key, previousLocks);\n    }\n\n    log(\n      'debug',\n      `🔐 - Taking the lock on \"${key}\" (queue length was ${locksLength})`,\n    );\n\n    let _resolve: () => void;\n    const releasePromise: Promise<void> = new Promise((resolve, reject) => {\n      _resolve = resolve;\n\n      if (LOCK_TIMEOUT !== Infinity) {\n        delay\n          .create(LOCK_TIMEOUT)\n          .then(() => reject(new YError('E_LOCK_TIMEOUT')));\n      }\n    });\n\n    const newLock = {\n      releasePromise,\n      release: _resolve,\n    };\n\n    previousLocks.push(newLock);\n\n    if (locksLength > 1) {\n      await previousLocks[locksLength - 2].releasePromise;\n    }\n  }\n\n  /**\n   * Release the lock on the given resource key\n   * @param  {String}   key  A unique key for the resource to release\n   * @return {void}\n   */\n  async function release(key) {\n    const actualLocks = LOCKS_MAP.get(key) || [];\n    const locksLength = actualLocks.length;\n\n    if (!locksLength) {\n      throw new YError('E_NO_LOCK', key);\n    }\n\n    log(\n      'debug',\n      `🔓 - Releasing the lock on \"${key}\" (queue length was ${locksLength})`,\n    );\n    actualLocks.shift().release();\n\n    if (locksLength === 0) {\n      LOCKS_MAP.delete(key);\n    }\n  }\n}\n"],"file":"lock.mjs"}