"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _yerror = _interopRequireDefault(require("yerror"));

var _delay = _interopRequireDefault(require("./delay.mock"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint max-nested-callbacks:0 */
describe('initDelayMock', () => {
  test('should work', done => {
    (0, _delay.default)({}).then(({
      service: {
        create,
        clear,
        __resolve,
        __resolveAll,
        __reject,
        __rejectAll
      }
    }) => {
      (0, _assert.default)('function' === typeof create);
      (0, _assert.default)('function' === typeof clear);
      (0, _assert.default)('function' === typeof __resolve);
      (0, _assert.default)('function' === typeof __resolveAll);
      (0, _assert.default)('function' === typeof __reject);
      (0, _assert.default)('function' === typeof __rejectAll);
    }).then(() => done()).catch(done);
  });
  describe('_resolve', () => {
    test('should work', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __resolve
        }
      }) => {
        const delayPromise = create(1000);
        return Promise.resolve([__resolve(delayPromise), delayPromise]);
      }).then(() => done()).catch(done);
    });
  });
  describe('_resolveAll', () => {
    test('should work with no pending delays', done => {
      (0, _delay.default)({}).then(({
        service: {
          __resolveAll
        }
      }) => __resolveAll()).then(() => done()).catch(done);
    });
    test('should work with one pending delay', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __resolveAll
        }
      }) => {
        const delayPromise = create(1000);
        return Promise.all([delayPromise, __resolveAll()]);
      }).then(() => done()).catch(done);
    });
    test('should work with 10 pending delays', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __resolveAll
        }
      }) => {
        const delayPromises = new Array(10).fill(1).map(() => create(1000));
        return Promise.all([__resolveAll(), ...delayPromises]);
      }).then(() => done()).catch(done);
    });
  });
  describe('_reject', () => {
    test('should work', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __reject
        }
      }) => {
        const delayPromise = create(1000);
        return Promise.all([__reject(delayPromise), delayPromise.then(() => {
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        }).catch(err => {
          _assert.default.equal(err.code, 'E_DELAY_CLEARED');
        })]);
      }).then(() => done()).catch(done);
    });
  });
  describe('_rejectAll', () => {
    test('should work with no pending delays', done => {
      (0, _delay.default)({}).then(({
        service: {
          __rejectAll
        }
      }) => __rejectAll()).then(() => done()).catch(done);
    });
    test('should work with one pending delay', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __rejectAll
        }
      }) => {
        const delayPromise = create(1000);
        return Promise.all([delayPromise.then(() => {
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        }).catch(err => {
          _assert.default.equal(err.code, 'E_DELAY_CLEARED');
        }), __rejectAll()]);
      }).then(() => done()).catch(done);
    });
    test('should work with 10 pending delays', done => {
      (0, _delay.default)({}).then(({
        service: {
          create,
          __rejectAll
        }
      }) => {
        const delayPromises = new Array(10).fill(1).map(() => create(1000)).map(delayPromise => delayPromise.then(() => {
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        }).catch(err => {
          _assert.default.equal(err.code, 'E_DELAY_CLEARED');
        }));
        return Promise.all([__rejectAll(), ...delayPromises]);
      }).then(() => done()).catch(done);
    });
  });
});
//# sourceMappingURL=delay.mock.test.js.map