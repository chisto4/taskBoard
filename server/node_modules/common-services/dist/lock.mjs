import YError from 'yerror';
import { service as _service, singleton } from 'knifecycle';

const noop = () => undefined;

export default singleton(_service(initLock, "lock", ["?LOCKS_MAP", "?LOCK_TIMEOUT", "delay", "?log"]), true);

async function initLock({
  LOCKS_MAP = new Map(),
  LOCK_TIMEOUT = Infinity,
  delay,
  log = noop
}) {
  log('debug', 'ðŸ”’ - Lock service initialized.');
  return {
    take,
    release
  };

  async function take(key) {
    const previousLocks = LOCKS_MAP.get(key) || [];
    const locksLength = previousLocks.length;

    if (locksLength === 0) {
      LOCKS_MAP.set(key, previousLocks);
    }

    log('debug', `ðŸ” - Taking the lock on "${key}" (queue length was ${locksLength})`);

    let _resolve;

    const releasePromise = new Promise((resolve, reject) => {
      _resolve = resolve;

      if (LOCK_TIMEOUT !== Infinity) {
        delay.create(LOCK_TIMEOUT).then(() => reject(new YError('E_LOCK_TIMEOUT')));
      }
    });
    const newLock = {
      releasePromise,
      release: _resolve
    };
    previousLocks.push(newLock);

    if (locksLength > 1) {
      await previousLocks[locksLength - 2].releasePromise;
    }
  }

  async function release(key) {
    const actualLocks = LOCKS_MAP.get(key) || [];
    const locksLength = actualLocks.length;

    if (!locksLength) {
      throw new YError('E_NO_LOCK', key);
    }

    log('debug', `ðŸ”“ - Releasing the lock on "${key}" (queue length was ${locksLength})`);
    actualLocks.shift().release();

    if (locksLength === 0) {
      LOCKS_MAP.delete(key);
    }
  }
}
//# sourceMappingURL=lock.mjs.map