{"version":3,"sources":["../src/process.ts"],"names":["DEFAULT_NODE_ENVS","DEFAULT_SIGNALS","noop","undefined","initProcess","NODE_ENV","PROCESS_NAME","SIGNALS","NODE_ENVS","log","exit","$instance","$fatalError","signalsListeners","map","signal","terminate","bind","shuttingDown","includes","YError","global","process","title","forEach","signalListener","on","promise","catch","err","stack","catchUncaughtException","shutdown","code","destroy","dispose","removeListener","service"],"mappings":"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","sourcesContent":["import YError from 'yerror';\nimport { autoProvider, singleton } from 'knifecycle';\nimport type { Knifecycle, FatalErrorService } from 'knifecycle';\nimport type { LogService } from './log';\n\nconst DEFAULT_NODE_ENVS = ['development', 'test', 'production'];\nconst DEFAULT_SIGNALS: NodeJS.Signals[] = ['SIGTERM', 'SIGINT'];\n\nfunction noop(): void {\n  return undefined;\n}\n\nexport type ProcessServiceConfig = {\n  NODE_ENV?: string;\n  PROCESS_NAME?: string;\n  SIGNALS?: NodeJS.Signals[];\n  NODE_ENVS?: string[];\n};\nexport type ProcessServiceDependencies = ProcessServiceConfig & {\n  NODE_ENV: string;\n  exit: typeof process.exit;\n  $instance: Knifecycle<unknown>;\n  $fatalError: FatalErrorService;\n  log?: LogService;\n};\n\n/* Architecture Note #1.5: Process\nThe `process` service takes care of the process status.\n\nIt returns nothing and should be injected only for its\n side effects.\n*/\n\nexport default singleton(autoProvider(initProcess));\n\n/**\n * Instantiate the process service\n * @name initProcess\n * @function\n * @param  {Object}   services\n * The services to inject\n * @return {Promise<Object>}\n * A promise of the process object\n */\nasync function initProcess({\n  NODE_ENV,\n  PROCESS_NAME = '',\n  SIGNALS = DEFAULT_SIGNALS,\n  NODE_ENVS = DEFAULT_NODE_ENVS,\n  log = noop,\n  exit,\n  $instance,\n  $fatalError,\n}: ProcessServiceDependencies): Promise<{\n  service: NodeJS.Process;\n  dispose: () => Promise<void>;\n}> {\n  const signalsListeners = SIGNALS.map<\n    [NodeJS.Signals, NodeJS.SignalsListener]\n  >((signal) => [signal, terminate.bind(null, signal)]);\n  let shuttingDown = null;\n\n  /* Architecture Note #1.5.1: Node environment filtering\n\n  It also forces NODE_ENV to be set to avoid unintentionnal\n   development version shipping to production. You can specify\n   your own list of valid environments by injecting the\n   `SIGNALS` optional dependency.\n  */\n  if (!NODE_ENVS.includes(NODE_ENV)) {\n    throw new YError('E_NODE_ENV', NODE_ENV);\n  }\n\n  log('warning', `🔂 - Running in \"${NODE_ENV}\" environment.`);\n\n  global.process.title =\n    (PROCESS_NAME || global.process.title) + ' - ' + NODE_ENV;\n\n  /* Architecture Note #1.5.2: Signals handling\n\n  It also handle SIGINT and SIGTERM signals to allow to\n   gracefully shutdown the running process. The signals\n   to handle can be customized by injecting the `SIGNALS`\n   optional dependencies.\n  */\n  signalsListeners.forEach(([signal, signalListener]) => {\n    global.process.on(signal, signalListener);\n  });\n\n  /* Architecture Note #1.5.3: Handling services fatal errors\n\n  If an error occurs it attempts to gracefully exit\n  to give it a chance to finish properly.\n  */\n  $fatalError.promise.catch((err) => {\n    log('error', '💀 - Fatal error');\n    log('stack', err.stack || err);\n    terminate('FATAL');\n  });\n\n  /* Architecture Note #1.5.4: Uncaught exceptions\n\n  If an uncaught exeption occurs it also attempts to\n   gracefully exit since a process should never be kept\n   alive when an uncaught exception is raised.\n  */\n  global.process.on('uncaughtException', catchUncaughtException);\n\n  function catchUncaughtException(err: Error) {\n    log('error', '💀 - Uncaught Exception');\n    log('stack', err.stack || err);\n    terminate('ERR');\n  }\n\n  function terminate(signal: NodeJS.Signals | 'ERR' | 'FATAL') {\n    if (shuttingDown) {\n      log('warning', `🚦 - ${signal} received again, shutdown now.`);\n      exit(1);\n    } else {\n      log(\n        'warning',\n        `🚦 - ${signal} received. Send it again to kill me instantly.`,\n      );\n      shutdown(['ERR', 'FATAL'].includes(signal) ? 1 : 0);\n    }\n  }\n\n  async function shutdown(code: number) {\n    shuttingDown = true;\n    log('warning', 'Shutting down now 🙏...');\n    await $instance.destroy();\n\n    try {\n      log('warning', '😎 - Gracefull shutdown sucessfully done !');\n      exit(code);\n    } catch (err) {\n      log('error', '🤔 - Could not gracefully shutdown.');\n      log('stack', err.stack || err);\n      exit(code);\n    }\n  }\n\n  async function dispose() {\n    global.process.removeListener('uncaughtException', catchUncaughtException);\n    signalsListeners.forEach(([signal, signalListener]) => {\n      global.process.removeListener(signal, signalListener);\n    });\n  }\n\n  log('debug', '📇 - Process service initialized.');\n  return {\n    service: global.process,\n    dispose,\n  };\n}\n"],"file":"process.js"}