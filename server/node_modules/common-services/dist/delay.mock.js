"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yerror = _interopRequireDefault(require("yerror"));

var _delay = _interopRequireDefault(require("./delay"));

var _knifecycle = require("knifecycle");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Architecture Note #1.4.1: Mocking delays

This mock is largely inspired by the `$timeout` one of
 AngularJS. It allows to resolve/reject pending delays
 for testing. That said, it does it asynchronously
 where the former one was synchronous. This is not a
 bug but a design choice to keep the closest possible
 to what would happen in actual code.
*/
var _default = (0, _knifecycle.reuseSpecialProps)(_delay.default, initDelayMock);
/**
 * Instantiate the delay service mock
 * @name initDelayMock
 * @function
 * @return {Promise<Object>}
 * A promise of the mocked delay service
 * @example
 * import initDelayMock from 'common-services/dist/delay.mock';
 * import assert from 'assert';
 *
 * const delay = await initDelayMock();
 *
 * const delayPromise = delay.create(1000);
 *
 * delay.resolve(delayPromise);
 *
 * delayPromise.then(() => {
 *   // Any code here will execute immediatly
 *   // instead of after a 1000ms delay
 * });
 */


exports.default = _default;

function initDelayMock(_) {
  const pendingPromises = [];
  return Promise.resolve({
    service: {
      create,
      clear,
      __resolve,
      __resolveAll,
      __reject,
      __rejectAll
    }
  });

  function create(_) {
    let _resolve;

    let _reject;

    const promise = new Promise((resolve, reject) => {
      _reject = reject;
      _resolve = resolve;
    });
    pendingPromises.push({
      promise,
      resolve: _resolve,
      reject: _reject
    });
    return promise;
  }

  async function clear(promise) {
    const pendingPromiseIndex = pendingPromises.findIndex(pendingPromise => pendingPromise.promise === promise);

    if (-1 === pendingPromiseIndex) {
      return Promise.reject(new _yerror.default('E_BAD_DELAY'));
    }

    pendingPromises[pendingPromiseIndex].reject(new _yerror.default('E_DELAY_CLEARED'));
    pendingPromises.splice(pendingPromiseIndex, 1);
    return Promise.resolve();
  }

  function __resolve(promise) {
    const pendingPromise = pendingPromises.find(pendingPromise => pendingPromise.promise === promise);

    if (!pendingPromise) {
      return Promise.reject(new _yerror.default('E_BAD_DELAY'));
    }

    pendingPromise.resolve();
    return Promise.resolve().then(__delete.bind(null, promise));
  }

  async function __resolveAll() {
    await Promise.all(pendingPromises.map(({
      promise
    }) => __resolve(promise)));
  }

  function __reject(promise) {
    const pendingPromise = pendingPromises.find(pendingPromise => pendingPromise.promise === promise);

    if (!pendingPromise) {
      return Promise.reject(new _yerror.default('E_BAD_DELAY'));
    }

    pendingPromise.reject(new _yerror.default('E_DELAY_CLEARED'));
    return Promise.resolve().then(__delete.bind(null, promise));
  }

  async function __rejectAll() {
    await Promise.all(pendingPromises.map(({
      promise
    }) => __reject(promise)));
  }

  function __delete(promise) {
    const pendingPromiseIndex = pendingPromises.findIndex(pendingPromise => pendingPromise.promise === promise);
    pendingPromises.splice(pendingPromiseIndex, 1);
  }
}
//# sourceMappingURL=delay.mock.js.map