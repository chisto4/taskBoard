{"version":3,"sources":["../src/util.ts"],"names":["YError","initDebug","debug","DECLARATION_SEPARATOR","OPTIONAL_FLAG","ALLOWED_INITIALIZER_TYPES","SPECIAL_PROPS_PREFIX","SPECIAL_PROPS","TYPE","NAME","INJECT","SINGLETON","EXTRA","VALUE","ALLOWED_SPECIAL_PROPS","Object","keys","map","key","E_BAD_INJECT_IN_CONSTANT","E_CONSTANT_INJECTION","parseInjections","source","options","matches","match","allowEmpty","trim","replace","split","s","filter","startsWith","injection","includes","shift","test","readFunctionName","aFunction","functionName","parseName","name","pop","_","$1","toLowerCase","reuseSpecialProps","from","to","amend","uniqueInitializer","bind","Set","concat","prop","reduce","fn","value","Array","assign","constant","contantLooksLikeAnInitializer","Function","$type","$name","$singleton","$value","service","serviceBuilder","dependencies","singleton","extra","autoService","toString","provider","providerBuilder","autoProvider","wrapInitializer","wrapper","baseInitializer","services","baseInstance","inject","initializer","useInject","mergeInject","alsoInject","autoInject","currentDependencies","parseDependencyDeclaration","addedDependencies","dedupedDependencies","serviceName","declarationIsOverridden","some","addedServiceName","mappedName","optional","isOptionalEverywhere","every","addedMappedName","stringifyDependencyDeclaration","extraInformations","merge","isSingleton","autoName","type","properties","finalProperties","property","finalProperty","handler","handlerFunction","args","autoHandler","dependencyDeclaration","slice","dependencyDeclarationParts","unwrapInitializerProperties","undefined"],"mappings":"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","sourcesContent":["/* eslint @typescript-eslint/ban-types:0 */\n\nimport YError from 'yerror';\nimport initDebug from 'debug';\n\nconst debug = initDebug('knifecycle');\n\n/* Architecture Note #1.2: Creating initializers\n\n`knifecycle` uses initializers at its a core. An initializer is basically\n an asynchronous function with some annotations:\n- name: it uniquely identifies the initializer so that it can be\n referred to as another initializer dependency.\n- type: an initializer can be of three types at the moment\n (constant, service or provider). The initializer annotations\n varies accordsing to those types as we'll see later on.\n- injected dependencies: an array of dependencies declarations that\n declares which initializer htis initializer depends on. Constants\n logically cannot have dependencies.\n- options: various options like for exemple, if the initializer\n implements the singleton pattern or not.\n- value: only used for constant, this property allows to know\n the value the initializer resolves to without actually executing it.\n- extra: an extra property for custom use that will be propagated\n by the various other decorators you'll find in this library.\n\n`Knifecycle` provides a set of decorators that allows you to simply\n create new initializers.\n*/\nexport const DECLARATION_SEPARATOR = '>';\nexport const OPTIONAL_FLAG = '?';\nexport const ALLOWED_INITIALIZER_TYPES = [\n  'provider',\n  'service',\n  'constant',\n] as const;\n\nexport type ServiceName = string;\nexport type Service = any;\nexport interface Disposer {\n  (): Promise<void>;\n}\nexport type FatalErrorProvider = Promise<void>;\nexport type Provider<S extends Service> = {\n  service: S;\n  dispose?: Disposer;\n  fatalErrorPromise?: FatalErrorProvider;\n};\nexport type Dependencies<S extends Service = Service> = { [name: string]: S };\nexport type DependencyName = string;\nexport type DependencyDeclaration = string;\nexport type ExtraInformations = any;\nexport type ParsedDependencyDeclaration = {\n  serviceName: string;\n  mappedName: string;\n  optional: boolean;\n};\n\nexport type ConstantProperties = {\n  $type: 'constant';\n  $name: DependencyName;\n  $singleton: true;\n};\nexport type ConstantInitializer<S extends Service> = ConstantProperties & {\n  $value: S;\n};\n\nexport type ProviderInitializerBuilder<\n  D extends Dependencies,\n  S extends Service\n> = (dependencies?: D) => Promise<Provider<S>>;\nexport type ProviderProperties = {\n  $type: 'provider';\n  $name: DependencyName;\n  $inject?: DependencyDeclaration[];\n  $singleton?: boolean;\n  $extra?: ExtraInformations;\n};\nexport type ProviderInitializer<D extends Dependencies, S extends Service> = (\n  dependencies?: D,\n) => Promise<Provider<S>>;\nexport type ProviderInputProperties = {\n  type: 'provider';\n  name: DependencyName;\n  inject?: DependencyDeclaration[];\n  singleton?: boolean;\n  extra?: ExtraInformations;\n};\n\nexport type ServiceInitializerBuilder<\n  D extends Dependencies,\n  S extends Service\n> = (dependencies?: D) => Promise<S>;\nexport type ServiceProperties = {\n  $type: 'service';\n  $name: DependencyName;\n  $inject?: DependencyDeclaration[];\n  $singleton?: boolean;\n  $extra?: ExtraInformations;\n};\nexport type ServiceInitializer<D extends Dependencies, S extends Service> = (\n  dependencies?: D,\n) => Promise<S>;\nexport type ServiceInputProperties = {\n  type: 'service';\n  name: DependencyName;\n  inject?: DependencyDeclaration[];\n  singleton?: boolean;\n  extra?: ExtraInformations;\n};\n\nexport type InitializerProperties =\n  | ConstantProperties\n  | ProviderProperties\n  | ServiceProperties;\n\nexport type AsyncInitializerBuilder<\n  D extends Dependencies,\n  S extends Service\n> = ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S>;\nexport type AsyncInitializer<D extends Dependencies, S extends Service> =\n  | ServiceInitializer<D, S>\n  | ProviderInitializer<D, S>;\nexport type PartialAsyncInitializer<\n  D extends Dependencies,\n  S extends Service\n> = Partial<ServiceInitializer<D, S>> | Partial<ProviderInitializer<D, S>>;\n\nexport type Initializer<S extends Service, D extends Dependencies> =\n  | ConstantInitializer<S>\n  | ServiceInitializer<D, S>\n  | ProviderInitializer<D, S>;\n\nexport type ServiceInitializerWrapper<\n  S extends Service,\n  D extends Dependencies\n> = (dependencies: D, baseService: S) => Promise<S>;\nexport type ProviderInitializerWrapper<\n  S extends Service,\n  D extends Dependencies\n> = (dependencies: D, baseService: Provider<S>) => Promise<Provider<S>>;\n\nexport type Parameters<V = any> = { [name: string]: V };\nexport interface HandlerFunction<\n  D extends Dependencies,\n  V,\n  P extends Parameters<V>,\n  U extends any[],\n  R\n> {\n  (dependencies: D, parameters?: P, ...args: U): Promise<R>;\n}\n\nexport const SPECIAL_PROPS_PREFIX = '$';\nexport const SPECIAL_PROPS = {\n  TYPE: `${SPECIAL_PROPS_PREFIX}type`,\n  NAME: `${SPECIAL_PROPS_PREFIX}name`,\n  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,\n  SINGLETON: `${SPECIAL_PROPS_PREFIX}singleton`,\n  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,\n  VALUE: `${SPECIAL_PROPS_PREFIX}value`,\n};\nexport const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(\n  (key) => SPECIAL_PROPS[key],\n);\n\nconst E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';\nconst E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';\n\nexport function parseInjections(\n  source: string,\n  options?: { allowEmpty: boolean },\n): DependencyDeclaration[] {\n  const matches = source.match(\n    /^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\{\\s*([^{}]+)(\\s*\\.\\.\\.[^{}]+|)\\s*\\}/,\n  );\n\n  if (!matches) {\n    if (!source.match(/^\\s*async/)) {\n      throw new YError('E_NON_ASYNC_INITIALIZER', source);\n    }\n    if (\n      options &&\n      options.allowEmpty &&\n      source.match(/^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\)/)\n    ) {\n      return [];\n    }\n    throw new YError('E_AUTO_INJECTION_FAILURE', source);\n  }\n\n  return matches[1]\n    .trim()\n    .replace(/,$/, '')\n    .split(/\\s*,\\s*/)\n    .map((s) => s.trim())\n    .filter((s) => !s.startsWith('...'))\n    .map(\n      (injection) =>\n        (injection.includes('=') ? '?' : '') +\n        injection\n          .split(/\\s*=\\s*/)\n          .shift()\n          .split(/\\s*:\\s*/)\n          .shift(),\n    )\n    .filter((injection) => !/[)(\\][]/.test(injection));\n}\n\nexport function readFunctionName(aFunction: Function): string {\n  if (typeof aFunction !== 'function') {\n    throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);\n  }\n\n  const functionName = parseName(aFunction.name || '');\n\n  if (!functionName) {\n    throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);\n  }\n\n  return functionName;\n}\n\nexport function parseName(functionName: string): string {\n  return functionName\n    .split(' ')\n    .pop()\n    .replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());\n}\n\n/**\n * Apply special props to the given initializer from another one\n *  and optionally amend with new special props\n * @param  {Function} from The initializer in which to pick the props\n * @param  {Function} to   The initializer from which to build the new one\n * @param  {Object}   [amend={}]   Some properties to override\n * @return {Function}      The newly built initializer\n */\nexport function reuseSpecialProps<FD, TD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<TD, S>,\n  amend?: Partial<ProviderProperties>,\n): ProviderInitializerBuilder<FD & TD, S>;\nexport function reuseSpecialProps<FD, TD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ServiceInitializerBuilder<TD, S>,\n  amend?: Partial<ServiceProperties>,\n): ServiceInitializerBuilder<FD & TD, S>;\nexport function reuseSpecialProps<FD, TD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<TD, S> | ServiceInitializerBuilder<TD, S>,\n  amend: Partial<ProviderProperties> | Partial<ServiceProperties> = {},\n):\n  | ProviderInitializerBuilder<FD & TD, S>\n  | ServiceInitializerBuilder<FD & TD, S> {\n  const uniqueInitializer = ((to as unknown) as Function).bind(null);\n\n  return [...new Set(Object.keys(from).concat(Object.keys(amend)))]\n    .filter((prop) => prop.startsWith(SPECIAL_PROPS_PREFIX))\n    .reduce((fn, prop) => {\n      const value =\n        'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];\n      if (value instanceof Array) {\n        fn[prop] = value.concat();\n      } else if (value instanceof Object) {\n        fn[prop] = Object.assign({}, value);\n      } else {\n        fn[prop] = value;\n      }\n      return fn;\n    }, uniqueInitializer);\n}\n\n/**\n * Decorator that creates an initializer for a constant value\n * @param  {String}    name\n * The constant's name.\n * @param  {any}  value\n * The constant's value\n * @return {Function}\n * Returns a new constant initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function constant<V extends Service>(\n  name: DependencyName,\n  value: V,\n): ConstantInitializer<V> {\n  const contantLooksLikeAnInitializer =\n    value instanceof Function && value[SPECIAL_PROPS.INJECT];\n\n  if (contantLooksLikeAnInitializer) {\n    throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);\n  }\n\n  debug(`Created an initializer from a constant: ${name}.`);\n\n  return {\n    $type: 'constant',\n    $name: name,\n    $singleton: true,\n    $value: value,\n  };\n}\n\n/**\n * Decorator that creates an initializer from a service builder\n * @param  {Function}   serviceBuilder\n * An async function to build the service\n * @param  {String}    [name]\n * The service's name\n * @param  {Array<String>}    [dependencies]\n * The service's injected dependencies\n * @param  {Boolean}    [singleton]\n * Whether the service is a singleton or not\n * @param  {any}    [extra]\n * Eventual extra informations\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *     true\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function service<D, S>(\n  serviceBuilder: ServiceInitializerBuilder<D, S>,\n  name?: DependencyName,\n  dependencies?: DependencyDeclaration[],\n  singleton?: boolean,\n  extra?: ExtraInformations,\n): ServiceInitializer<D, S> {\n  if (!serviceBuilder) {\n    throw new YError('E_NO_SERVICE_BUILDER');\n  }\n\n  name = name || serviceBuilder[SPECIAL_PROPS.NAME] || 'anonymous';\n  dependencies = dependencies || serviceBuilder[SPECIAL_PROPS.INJECT] || [];\n  singleton =\n    typeof singleton === 'undefined'\n      ? serviceBuilder[SPECIAL_PROPS.SINGLETON] || false\n      : singleton;\n  extra = extra || serviceBuilder[SPECIAL_PROPS.EXTRA] || [];\n\n  debug(`Created an initializer from a service builder: ${name}.`);\n\n  const uniqueInitializer = reuseSpecialProps(serviceBuilder, serviceBuilder, {\n    [SPECIAL_PROPS.TYPE]: 'service',\n    [SPECIAL_PROPS.NAME]: name,\n    [SPECIAL_PROPS.INJECT]: dependencies,\n    [SPECIAL_PROPS.SINGLETON]: singleton,\n    [SPECIAL_PROPS.EXTRA]: extra,\n  }) as ServiceInitializer<D, S>;\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer from a service\n *  builder by automatically detecting its name\n *  and dependencies\n * @param  {Function}   serviceBuilder\n * An async function to build the service\n * @return {Function}\n * Returns a new initializer\n */\nexport function autoService<D, S>(\n  serviceBuilder: ServiceInitializerBuilder<D, S>,\n): ServiceInitializer<D, S> {\n  const name = readFunctionName(serviceBuilder as Function);\n  const source = serviceBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return service(serviceBuilder, name, dependencies);\n}\n\n/**\n * Decorator that creates an initializer for a provider\n *  builder\n * @param  {Function} providerBuilder\n * An async function to build the service provider\n * @param  {String} [name]\n * The service's name\n * @param  {Array<String>} [dependencies]\n * The service's dependencies\n * @param  {Boolean} [singleton]\n * Whether the service is a singleton or not\n * @param  {any} [extra]\n * Eventual extra informations\n * @return {Function}\n * Returns a new provider initializer\n * @example\n *\n * import Knifecycle, { provider } from 'knifecycle'\n * import fs from 'fs';\n *\n * const $ = new Knifecycle();\n *\n * $.register(provider(configProvider, 'config'));\n *\n * async function configProvider() {\n *   return new Promise((resolve, reject) {\n *     fs.readFile('config.js', function(err, data) {\n *       let config;\n *\n *       if(err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       try {\n *         config = JSON.parse(data.toString);\n *       } catch (err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       resolve({\n *         service: config,\n *       });\n *     });\n *   });\n * }\n */\nexport function provider<D, S>(\n  providerBuilder: ProviderInitializerBuilder<D, S>,\n  name?: DependencyName,\n  dependencies?: DependencyDeclaration[],\n  singleton?: boolean,\n  extra?: ExtraInformations,\n): ProviderInitializer<D, S> {\n  if (!providerBuilder) {\n    throw new YError('E_NO_PROVIDER_BUILDER');\n  }\n\n  name = name || providerBuilder[SPECIAL_PROPS.NAME] || 'anonymous';\n  dependencies = dependencies || providerBuilder[SPECIAL_PROPS.INJECT] || [];\n  singleton =\n    typeof singleton === 'undefined'\n      ? providerBuilder[SPECIAL_PROPS.SINGLETON] || false\n      : singleton;\n  extra = extra || providerBuilder[SPECIAL_PROPS.EXTRA] || [];\n\n  debug(\n    `Created an initializer from a provider builder: ${name || 'anonymous'}.`,\n  );\n\n  const uniqueInitializer = reuseSpecialProps(\n    providerBuilder,\n    providerBuilder,\n    {\n      [SPECIAL_PROPS.TYPE]: 'provider',\n      [SPECIAL_PROPS.NAME]: name,\n      [SPECIAL_PROPS.INJECT]: dependencies,\n      [SPECIAL_PROPS.SINGLETON]: singleton,\n      [SPECIAL_PROPS.EXTRA]: extra,\n    },\n  ) as ProviderInitializer<D, S>;\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer from a provider\n *  builder by automatically detecting its name\n *  and dependencies\n * @param  {Function}   providerBuilder\n * An async function to build the service provider\n * @return {Function}\n * Returns a new provider initializer\n */\nexport function autoProvider<D, S>(\n  providerBuilder: ProviderInitializerBuilder<D, S>,\n): ProviderInitializer<D, S> {\n  const name = readFunctionName(providerBuilder as Function);\n  const source = providerBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return provider(providerBuilder, name, dependencies);\n}\n\n/**\n * Allows to wrap an initializer to add extra initialization steps\n * @param  {Function} wrapper\n * A function taking dependencies and the base\n * service in arguments\n * @param  {Function} baseInitializer\n * The initializer to decorate\n * @return {Function}\n * The new initializer\n */\n\nexport function wrapInitializer<D, S>(\n  wrapper: ProviderInitializerWrapper<S, D>,\n  baseInitializer: ProviderInitializer<D, S>,\n): ProviderInitializer<D, S>;\nexport function wrapInitializer<D, S>(\n  wrapper: ServiceInitializerWrapper<S, D>,\n  baseInitializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function wrapInitializer<D, S>(\n  wrapper: ProviderInitializerWrapper<S, D> | ServiceInitializerWrapper<S, D>,\n  baseInitializer: ProviderInitializer<D, S> | ServiceInitializer<D, S>,\n): ProviderInitializer<D, S> | ServiceInitializer<D, S> {\n  return reuseSpecialProps(baseInitializer, async (services: D) => {\n    const baseInstance = await baseInitializer(services);\n\n    return (wrapper as ServiceInitializerWrapper<S, D>)(\n      services,\n      baseInstance as S,\n    );\n  }) as ServiceInitializer<D, S>;\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to declare which\n *  services the initializer needs to provide its\n *  own service\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n *  .register(\n *    service(\n *      inject(['ENV'], myServiceInitializer)\n *      'myService',\n *    )\n *   )\n * );\n */\nexport function inject<D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer: ProviderInitializer<unknown, S>,\n): ProviderInitializer<D, S>;\nexport function inject<D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer: ProviderInitializerBuilder<unknown, S>,\n): ProviderInitializerBuilder<D, S>;\nexport function inject<D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer: ServiceInitializer<unknown, S>,\n): ServiceInitializer<D, S>;\nexport function inject<D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer: ServiceInitializerBuilder<unknown, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function inject<D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer:\n    | ProviderInitializerBuilder<unknown, S>\n    | ServiceInitializerBuilder<unknown, S>,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {\n    throw new YError(\n      E_BAD_INJECT_IN_CONSTANT,\n      initializer[SPECIAL_PROPS.NAME],\n      dependencies,\n    );\n  }\n\n  const uniqueInitializer = reuseSpecialProps<D, {}, S>(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    {\n      [SPECIAL_PROPS.INJECT]: dependencies,\n    },\n  );\n\n  debug('Wrapped an initializer with dependencies:', dependencies);\n\n  return uniqueInitializer;\n}\n\n/**\n * Apply injected dependencies from the given initializer to another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function useInject<FD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializer<unknown, S>,\n): ProviderInitializer<FD, S>;\nexport function useInject<FD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<unknown, S>,\n): ProviderInitializerBuilder<FD, S>;\nexport function useInject<FD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ServiceInitializer<unknown, S>,\n): ServiceInitializer<FD, S>;\nexport function useInject<FD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ServiceInitializerBuilder<unknown, S>,\n): ServiceInitializerBuilder<FD, S>;\nexport function useInject<FD, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<unknown, S>,\n): ProviderInitializerBuilder<FD, S> | ServiceInitializerBuilder<FD, S> {\n  return inject<FD, S>(from[SPECIAL_PROPS.INJECT] || [], to);\n}\n\n/**\n * Merge injected dependencies of the given initializer with another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function mergeInject<FD, D, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializer<D, S>,\n): ProviderInitializer<FD & D, S>;\nexport function mergeInject<FD, D, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<FD & D, S>;\nexport function mergeInject<FD, D, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ServiceInitializer<D, S>,\n): ServiceInitializer<FD, S>;\nexport function mergeInject<FD, D, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<FD, S>;\nexport function mergeInject<FD, D, S>(\n  from:\n    | AsyncInitializerBuilder<FD, unknown>\n    | PartialAsyncInitializer<FD, unknown>,\n  to: ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S>,\n):\n  | ProviderInitializerBuilder<D & FD, S>\n  | ServiceInitializerBuilder<D & FD, S> {\n  return alsoInject(\n    from[SPECIAL_PROPS.INJECT] || ([] as DependencyDeclaration[]),\n    to as ServiceInitializerBuilder<D, S>,\n  );\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it according to the\n *  given function signature.\n * @param  {Function}  initializer\n * The original initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { autoInject, name } from 'knifecycle'\n *\n * new Knifecycle()\n *   .register(\n *     name(\n *       'application',\n *       autoInject(\n *         async ({ NODE_ENV, mysql: db }) =>\n *           async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])\n *         )\n *       )\n *     )\n *   )\n * );\n */\nexport function autoInject<D, S>(\n  initializer: ProviderInitializer<D, S>,\n): ProviderInitializer<D, S>;\nexport function autoInject<D, S>(\n  initializer: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S>;\nexport function autoInject<D, S>(\n  initializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function autoInject<D, S>(\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function autoInject<D, S>(\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  const source = initializer.toString();\n  const dependencies = parseInjections(source);\n\n  return inject(dependencies, initializer as ServiceInitializerBuilder<D, S>);\n}\n\n/**\n * Decorator creating a new initializer with some\n *  more dependencies declarations appended to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to append\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { alsoInject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   alsoInject(['ENV'], myServiceInitializer),\n *   'myService',\n * ));\n */\nexport function alsoInject<ND, D, S>(\n  dependencies: DependencyDeclaration[],\n  to: ProviderInitializer<D, S>,\n): ProviderInitializer<ND & D, S>;\nexport function alsoInject<ND, D, S>(\n  dependencies: DependencyDeclaration[],\n  to: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<ND & D, S>;\nexport function alsoInject<ND, D, S>(\n  dependencies: DependencyDeclaration[],\n  to: ServiceInitializer<D, S>,\n): ServiceInitializer<ND & D, S>;\nexport function alsoInject<ND, D, S>(\n  dependencies: DependencyDeclaration[],\n  to: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<ND & D, S>;\nexport function alsoInject<ND, D, S>(\n  dependencies: DependencyDeclaration[],\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n):\n  | ProviderInitializerBuilder<ND & D, S>\n  | ServiceInitializerBuilder<ND & D, S> {\n  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(\n    parseDependencyDeclaration,\n  );\n  const addedDependencies = dependencies.map(parseDependencyDeclaration);\n  const dedupedDependencies: DependencyDeclaration[] = currentDependencies\n    .filter(({ serviceName }) => {\n      const declarationIsOverridden = addedDependencies.some(\n        ({ serviceName: addedServiceName }) => {\n          return addedServiceName === serviceName;\n        },\n      );\n\n      return !declarationIsOverridden;\n    })\n    .concat(\n      addedDependencies.map(({ serviceName, mappedName, optional }) => {\n        const isOptionalEverywhere =\n          optional &&\n          currentDependencies.every(\n            ({ optional, mappedName: addedMappedName }) => {\n              return addedMappedName !== mappedName || optional;\n            },\n          );\n        return {\n          serviceName,\n          mappedName,\n          optional: isOptionalEverywhere,\n        };\n      }),\n    )\n    .map(stringifyDependencyDeclaration);\n\n  return inject(\n    dedupedDependencies,\n    initializer as ServiceInitializerBuilder<D, S>,\n  );\n}\n\n/**\n * Decorator creating a new initializer with some\n *  extra informations appended to it. It is just\n *  a way for user to store some additional\n *  informations but has no interaction with the\n *  Knifecycle internals.\n * @param  {Object}  extraInformations\n * An object containing those extra informations.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {Boolean}   [merge=false]\n * Whether the extra object should be merged\n * with the existing one or not\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { extra } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   extra({ httpHandler: true }, myServiceInitializer),\n *   'myService',\n * ));\n */\n\nexport function extra<D, S>(\n  extraInformations: ExtraInformations,\n  initializer: ProviderInitializer<D, S>,\n  merge?: boolean,\n): ProviderInitializer<D, S>;\nexport function extra<D, S>(\n  extraInformations: ExtraInformations,\n  initializer: ProviderInitializerBuilder<D, S>,\n  merge?: boolean,\n): ProviderInitializerBuilder<D, S>;\nexport function extra<D, S>(\n  extraInformations: ExtraInformations,\n  initializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function extra<D, S>(\n  extraInformations: ExtraInformations,\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function extra<D, S>(\n  extraInformations: ExtraInformations,\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n  merge = false,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    {\n      [SPECIAL_PROPS.EXTRA]: merge\n        ? Object.assign(\n            initializer[SPECIAL_PROPS.EXTRA] || {},\n            extraInformations,\n          )\n        : extraInformations,\n    },\n  );\n\n  debug('Wrapped an initializer with extra informations:', extraInformations);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer singleton option.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {boolean}    [isSingleton=true]\n * Define the initializer singleton option\n * (one instance for several runs if true)\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject, singleton } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   inject(['ENV'],\n *     singleton(myServiceInitializer)\n *   ),\n *   'myService',\n * ));\n */\nexport function singleton<D, S>(\n  initializer: ProviderInitializer<D, S>,\n  isSingleton?: boolean,\n): ProviderInitializer<D, S>;\nexport function singleton<D, S>(\n  initializer: ProviderInitializerBuilder<D, S>,\n  isSingleton?: boolean,\n): ProviderInitializerBuilder<D, S>;\nexport function singleton<D, S>(\n  initializer: ServiceInitializer<D, S>,\n  isSingleton?: boolean,\n): ServiceInitializer<D, S>;\nexport function singleton<D, S>(\n  initializer: ServiceInitializerBuilder<D, S>,\n  isSingleton?: boolean,\n): ServiceInitializerBuilder<D, S>;\nexport function singleton<D, S>(\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n  isSingleton = true,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    {\n      [SPECIAL_PROPS.SINGLETON]: isSingleton,\n    },\n  );\n\n  debug('Marked an initializer as singleton:', isSingleton);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name.\n * @param  {String}    name\n * The name of the service the initializer resolves to.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { name } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(name('myService', myServiceInitializer));\n */\nexport function name<D, S>(\n  name: DependencyName,\n  initializer: ProviderInitializer<D, S>,\n): ProviderInitializer<D, S>;\nexport function name<D, S>(\n  name: DependencyName,\n  initializer: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S>;\nexport function name<D, S>(\n  name: DependencyName,\n  initializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function name<D, S>(\n  name: DependencyName,\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function name<D, S>(\n  name: DependencyName,\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    {\n      [SPECIAL_PROPS.NAME]: name,\n    },\n  );\n\n  debug('Wrapped an initializer with a name:', name);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name from its function name.\n * @param  {Function}  initializer\n * The initializer to name\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { autoName } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoName(async function myService() {}));\n */\nexport function autoName<D, S>(\n  initializer: ProviderInitializer<D, S>,\n): ProviderInitializer<D, S>;\nexport function autoName<D, S>(\n  initializer: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S>;\nexport function autoName<D, S>(\n  initializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function autoName<D, S>(\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function autoName<D, S>(\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  return name(\n    readFunctionName(initializer),\n    initializer as ServiceInitializerBuilder<D, S>,\n  );\n}\n\n/**\n * Decorator to set an initializer type.\n * @param  {String}    type\n * The type to set to the initializer.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { name, type } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(\n *   type('service',\n *     name('myService',\n *       myServiceInitializer\n *     )\n *   )\n * );\n */\nexport function type<D, S>(\n  type: 'provider',\n  initializer: ProviderInitializer<D, S>,\n): ProviderInitializer<D, S>;\nexport function type<D, S>(\n  type: 'provider',\n  initializer: ProviderInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S>;\nexport function type<D, S>(\n  type: 'service',\n  initializer: ServiceInitializer<D, S>,\n): ServiceInitializer<D, S>;\nexport function type<D, S>(\n  type: 'service',\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializerBuilder<D, S>;\nexport function type<D, S>(\n  type: 'service' | 'provider',\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n): ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S> {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    {\n      [SPECIAL_PROPS.TYPE]: type,\n    },\n  );\n\n  debug('Wrapped an initializer with a type:', type);\n\n  return uniqueInitializer as ServiceInitializerBuilder<D, S>;\n}\n\n/**\n * Decorator to set an initializer properties.\n * @param  {Object}    properties\n * Properties to set to the service.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { initializer } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(initializer({\n *   name: 'myService',\n *   type: 'service',\n *   inject: ['ENV'],\n *   singleton: true,\n * }, myServiceInitializer));\n */\nexport function initializer<D, S>(\n  properties: ProviderInputProperties,\n  initializer: ProviderInitializerBuilder<D, S>,\n): ProviderInitializer<D, S>;\nexport function initializer<D, S>(\n  properties: ServiceInputProperties,\n  initializer: ServiceInitializerBuilder<D, S>,\n): ServiceInitializer<D, S>;\nexport function initializer<D, S>(\n  properties: ServiceInputProperties | ProviderInputProperties,\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>,\n): ProviderInitializer<D, S> | ServiceInitializer<D, S> {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer as ServiceInitializerBuilder<D, S>,\n    Object.keys(properties).reduce((finalProperties, property) => {\n      const finalProperty = SPECIAL_PROPS_PREFIX + property;\n\n      if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {\n        throw new YError('E_BAD_PROPERTY', property);\n      }\n      finalProperties[finalProperty] = properties[property];\n      return finalProperties;\n    }, {}),\n  );\n\n  debug('Wrapped an initializer with properties:', properties);\n\n  return uniqueInitializer as ServiceInitializer<D, S>;\n}\n\n/**\n * Shortcut to create an initializer with a simple handler\n * @param  {Function} handlerFunction\n * The handler function\n * @param  {String}  [name]\n * The name of the handler. Default to the DI prop if exists\n * @param  {Array<String>}  [dependencies=[]]\n * The dependencies to inject in it\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { handler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(handler(getUser, 'getUser', ['db', '?log']));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function handler<\n  D extends Dependencies,\n  V,\n  P extends Parameters<V>,\n  U extends unknown[],\n  R\n>(\n  handlerFunction: HandlerFunction<D, V, P, U, R>,\n  name?: ServiceName,\n  dependencies?: DependencyDeclaration[],\n  singleton?: boolean,\n  extra?: ExtraInformations,\n): ServiceInitializer<D, (parameters: P, ...args: U) => Promise<R>> {\n  name = name || handlerFunction[SPECIAL_PROPS.NAME];\n  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT] || [];\n\n  if (!name) {\n    throw new YError('E_NO_HANDLER_NAME', handlerFunction);\n  }\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n      singleton,\n      extra,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/**\n * Allows to create an initializer with a simple handler automagically\n * @param  {Function} handlerFunction\n * The handler function\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { autoHandler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoHandler(getUser));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function autoHandler<\n  D extends Dependencies,\n  V,\n  P extends Parameters<V>,\n  U extends unknown[],\n  R\n>(\n  handlerFunction: HandlerFunction<D, V, P, U, R>,\n): ServiceInitializer<D, (parameters: P, ...args: U) => Promise<R>> {\n  const name = readFunctionName(handlerFunction);\n  const source = handlerFunction.toString();\n  const dependencies = parseInjections(source);\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/* Architecture Note #1.2.1: Dependencies declaration syntax\n\nThe dependencies syntax is of the following form:\n `?serviceName>mappedName`\nThe `?` flag indicates an optional dependency.\n `>mappedName` is optional and allows to inject\n `mappedName` as `serviceName`.\nIt allows to write generic services with fixed\n dependencies and remap their name at injection time.\n*/\n\n/**\n * Explode a dependency declaration an returns its parts.\n * @param  {String}  dependencyDeclaration\n * A dependency declaration string\n * @return {Object}\n * The various parts of it\n * @example\n * parseDependencyDeclaration('pgsql>db');\n * // Returns\n * {\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * }\n */\nexport function parseDependencyDeclaration(\n  dependencyDeclaration: DependencyDeclaration,\n): ParsedDependencyDeclaration {\n  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);\n  const [serviceName, mappedName] = (optional\n    ? dependencyDeclaration.slice(1)\n    : dependencyDeclaration\n  ).split(DECLARATION_SEPARATOR);\n\n  return {\n    serviceName,\n    mappedName: mappedName || serviceName,\n    optional,\n  };\n}\n\n/**\n * Stringify a dependency declaration from its parts.\n * @param  {Object}  dependencyDeclarationParts\n * A dependency declaration string\n * @return {String}\n * The various parts of it\n * @example\n * stringifyDependencyDeclaration({\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * });\n *\n * // Returns\n * 'pgsql>db'\n */\nexport function stringifyDependencyDeclaration(\n  dependencyDeclarationParts: ParsedDependencyDeclaration,\n): DependencyDeclaration {\n  return `${dependencyDeclarationParts.optional ? '?' : ''}${\n    dependencyDeclarationParts.serviceName\n  }${\n    dependencyDeclarationParts.mappedName !==\n    dependencyDeclarationParts.serviceName\n      ? '>' + dependencyDeclarationParts.mappedName\n      : ''\n  }`;\n}\n\n/* Architecture Note #3: TypeScript tweaks\n\nSadly TypeScript does not allow to add generic types\n in all cases. This is why `(Service|Provider)Initializer`\n types do not embed the `(Service|Provider)Properties`\n direclty. Instead, we use this utility function to\n reveal it to TypeScript and, by the way, check their\n completeness at execution time.\n\nFor more details, see:\nhttps://stackoverflow.com/questions/64948037/generics-type-loss-while-infering/64950184#64950184\n*/\n\n/**\n * Utility function to check and reveal initializer properties.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns revealed initializer (with TypeScript types for properties)\n */\nexport function unwrapInitializerProperties<S, D>(\n  initializer: ProviderInitializer<D, S>,\n): ProviderProperties;\nexport function unwrapInitializerProperties<S, D>(\n  initializer: ServiceInitializer<D, S>,\n): ServiceProperties;\nexport function unwrapInitializerProperties<S, D>(\n  initializer: ConstantInitializer<S>,\n): ConstantProperties;\nexport function unwrapInitializerProperties<S, D>(\n  initializer: Initializer<S, D>,\n): InitializerProperties;\nexport function unwrapInitializerProperties<S, D>(\n  initializer:\n    | ProviderInitializerBuilder<D, S>\n    | ServiceInitializerBuilder<D, S>\n    | ConstantInitializer<S>,\n): ProviderProperties | ServiceProperties | ConstantProperties {\n  if (typeof initializer !== 'function' && typeof initializer !== 'object') {\n    throw new YError('E_BAD_INITIALIZER', initializer);\n  }\n  const properties = initializer as InitializerProperties;\n\n  if (\n    typeof properties[SPECIAL_PROPS.NAME] !== 'string' ||\n    properties[SPECIAL_PROPS.NAME] === ''\n  ) {\n    throw new YError('E_ANONYMOUS_ANALYZER', properties[SPECIAL_PROPS.NAME]);\n  }\n\n  if (!ALLOWED_INITIALIZER_TYPES.includes(properties[SPECIAL_PROPS.TYPE])) {\n    throw new YError(\n      'E_BAD_INITIALIZER_TYPE',\n      initializer[SPECIAL_PROPS.NAME],\n      initializer[SPECIAL_PROPS.TYPE],\n      ALLOWED_INITIALIZER_TYPES,\n    );\n  }\n\n  if (\n    initializer[SPECIAL_PROPS.NAME] === '$autoload' &&\n    !initializer[SPECIAL_PROPS.SINGLETON]\n  ) {\n    throw new YError(\n      'E_BAD_AUTOLOADER',\n      initializer[SPECIAL_PROPS.SINGLETON] || false,\n    );\n  }\n\n  if (properties[SPECIAL_PROPS.TYPE] === 'constant') {\n    if (\n      'undefined' ===\n      typeof (initializer as ConstantInitializer<S>)[SPECIAL_PROPS.VALUE]\n    ) {\n      throw new YError(\n        'E_UNDEFINED_CONSTANT_INITIALIZER',\n        properties[SPECIAL_PROPS.NAME],\n      );\n    }\n    properties[SPECIAL_PROPS.SINGLETON] = true;\n  } else {\n    if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {\n      throw new YError(\n        'E_BAD_VALUED_NON_CONSTANT_INITIALIZER',\n        initializer[SPECIAL_PROPS.NAME],\n      );\n    }\n    properties[SPECIAL_PROPS.INJECT] = properties[SPECIAL_PROPS.INJECT] || [];\n    properties[SPECIAL_PROPS.SINGLETON] =\n      properties[SPECIAL_PROPS.SINGLETON] || false;\n    properties[SPECIAL_PROPS.EXTRA] =\n      properties[SPECIAL_PROPS.EXTRA] || undefined;\n  }\n\n  return initializer as\n    | (ProviderInitializer<D, S> & ProviderProperties)\n    | (ServiceInitializer<D, S> & ServiceProperties)\n    | ConstantInitializer<S>;\n}\n"],"file":"util.mjs"}