"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInjections = parseInjections;
exports.readFunctionName = readFunctionName;
exports.parseName = parseName;
exports.reuseSpecialProps = reuseSpecialProps;
exports.constant = constant;
exports.service = service;
exports.autoService = autoService;
exports.provider = provider;
exports.autoProvider = autoProvider;
exports.wrapInitializer = wrapInitializer;
exports.inject = inject;
exports.useInject = useInject;
exports.mergeInject = mergeInject;
exports.autoInject = autoInject;
exports.alsoInject = alsoInject;
exports.extra = extra;
exports.singleton = singleton;
exports.name = name;
exports.autoName = autoName;
exports.type = type;
exports.initializer = initializer;
exports.handler = handler;
exports.autoHandler = autoHandler;
exports.parseDependencyDeclaration = parseDependencyDeclaration;
exports.stringifyDependencyDeclaration = stringifyDependencyDeclaration;
exports.unwrapInitializerProperties = unwrapInitializerProperties;
exports.ALLOWED_SPECIAL_PROPS = exports.SPECIAL_PROPS = exports.SPECIAL_PROPS_PREFIX = exports.ALLOWED_INITIALIZER_TYPES = exports.OPTIONAL_FLAG = exports.DECLARATION_SEPARATOR = void 0;

var _yerror = _interopRequireDefault(require("yerror"));

var _debug = _interopRequireDefault(require("debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint @typescript-eslint/ban-types:0 */
const debug = (0, _debug.default)('knifecycle');
/* Architecture Note #1.2: Creating initializers

`knifecycle` uses initializers at its a core. An initializer is basically
 an asynchronous function with some annotations:
- name: it uniquely identifies the initializer so that it can be
 referred to as another initializer dependency.
- type: an initializer can be of three types at the moment
 (constant, service or provider). The initializer annotations
 varies accordsing to those types as we'll see later on.
- injected dependencies: an array of dependencies declarations that
 declares which initializer htis initializer depends on. Constants
 logically cannot have dependencies.
- options: various options like for exemple, if the initializer
 implements the singleton pattern or not.
- value: only used for constant, this property allows to know
 the value the initializer resolves to without actually executing it.
- extra: an extra property for custom use that will be propagated
 by the various other decorators you'll find in this library.

`Knifecycle` provides a set of decorators that allows you to simply
 create new initializers.
*/

const DECLARATION_SEPARATOR = '>';
exports.DECLARATION_SEPARATOR = DECLARATION_SEPARATOR;
const OPTIONAL_FLAG = '?';
exports.OPTIONAL_FLAG = OPTIONAL_FLAG;
const ALLOWED_INITIALIZER_TYPES = ['provider', 'service', 'constant'];
exports.ALLOWED_INITIALIZER_TYPES = ALLOWED_INITIALIZER_TYPES;
const SPECIAL_PROPS_PREFIX = '$';
exports.SPECIAL_PROPS_PREFIX = SPECIAL_PROPS_PREFIX;
const SPECIAL_PROPS = {
  TYPE: `${SPECIAL_PROPS_PREFIX}type`,
  NAME: `${SPECIAL_PROPS_PREFIX}name`,
  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,
  SINGLETON: `${SPECIAL_PROPS_PREFIX}singleton`,
  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,
  VALUE: `${SPECIAL_PROPS_PREFIX}value`
};
exports.SPECIAL_PROPS = SPECIAL_PROPS;
const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(key => SPECIAL_PROPS[key]);
exports.ALLOWED_SPECIAL_PROPS = ALLOWED_SPECIAL_PROPS;
const E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';
const E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';

function parseInjections(source, options) {
  const matches = source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\{\s*([^{}]+)(\s*\.\.\.[^{}]+|)\s*\}/);

  if (!matches) {
    if (!source.match(/^\s*async/)) {
      throw new _yerror.default('E_NON_ASYNC_INITIALIZER', source);
    }

    if (options && options.allowEmpty && source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\)/)) {
      return [];
    }

    throw new _yerror.default('E_AUTO_INJECTION_FAILURE', source);
  }

  return matches[1].trim().replace(/,$/, '').split(/\s*,\s*/).map(s => s.trim()).filter(s => !s.startsWith('...')).map(injection => (injection.includes('=') ? '?' : '') + injection.split(/\s*=\s*/).shift().split(/\s*:\s*/).shift()).filter(injection => !/[)(\][]/.test(injection));
}

function readFunctionName(aFunction) {
  if (typeof aFunction !== 'function') {
    throw new _yerror.default('E_AUTO_NAMING_FAILURE', typeof aFunction);
  }

  const functionName = parseName(aFunction.name || '');

  if (!functionName) {
    throw new _yerror.default('E_AUTO_NAMING_FAILURE', aFunction.name);
  }

  return functionName;
}

function parseName(functionName) {
  return functionName.split(' ').pop().replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());
}
/**
 * Apply special props to the given initializer from another one
 *  and optionally amend with new special props
 * @param  {Function} from The initializer in which to pick the props
 * @param  {Function} to   The initializer from which to build the new one
 * @param  {Object}   [amend={}]   Some properties to override
 * @return {Function}      The newly built initializer
 */


function reuseSpecialProps(from, to, amend = {}) {
  const uniqueInitializer = to.bind(null);
  return [...new Set(Object.keys(from).concat(Object.keys(amend)))].filter(prop => prop.startsWith(SPECIAL_PROPS_PREFIX)).reduce((fn, prop) => {
    const value = 'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];

    if (value instanceof Array) {
      fn[prop] = value.concat();
    } else if (value instanceof Object) {
      fn[prop] = Object.assign({}, value);
    } else {
      fn[prop] = value;
    }

    return fn;
  }, uniqueInitializer);
}
/**
 * Decorator that creates an initializer for a constant value
 * @param  {String}    name
 * The constant's name.
 * @param  {any}  value
 * The constant's value
 * @return {Function}
 * Returns a new constant initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */


function constant(name, value) {
  const contantLooksLikeAnInitializer = value instanceof Function && value[SPECIAL_PROPS.INJECT];

  if (contantLooksLikeAnInitializer) {
    throw new _yerror.default(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);
  }

  debug(`Created an initializer from a constant: ${name}.`);
  return {
    $type: 'constant',
    $name: name,
    $singleton: true,
    $value: value
  };
}
/**
 * Decorator that creates an initializer from a service builder
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @param  {String}    [name]
 * The service's name
 * @param  {Array<String>}    [dependencies]
 * The service's injected dependencies
 * @param  {Boolean}    [singleton]
 * Whether the service is a singleton or not
 * @param  {any}    [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *     true
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */


function service(serviceBuilder, name, dependencies, singleton, extra) {
  if (!serviceBuilder) {
    throw new _yerror.default('E_NO_SERVICE_BUILDER');
  }

  name = name || serviceBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
  dependencies = dependencies || serviceBuilder[SPECIAL_PROPS.INJECT] || [];
  singleton = typeof singleton === 'undefined' ? serviceBuilder[SPECIAL_PROPS.SINGLETON] || false : singleton;
  extra = extra || serviceBuilder[SPECIAL_PROPS.EXTRA] || [];
  debug(`Created an initializer from a service builder: ${name}.`);
  const uniqueInitializer = reuseSpecialProps(serviceBuilder, serviceBuilder, {
    [SPECIAL_PROPS.TYPE]: 'service',
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.SINGLETON]: singleton,
    [SPECIAL_PROPS.EXTRA]: extra
  });
  return uniqueInitializer;
}
/**
 * Decorator that creates an initializer from a service
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @return {Function}
 * Returns a new initializer
 */


function autoService(serviceBuilder) {
  const name = readFunctionName(serviceBuilder);
  const source = serviceBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return service(serviceBuilder, name, dependencies);
}
/**
 * Decorator that creates an initializer for a provider
 *  builder
 * @param  {Function} providerBuilder
 * An async function to build the service provider
 * @param  {String} [name]
 * The service's name
 * @param  {Array<String>} [dependencies]
 * The service's dependencies
 * @param  {Boolean} [singleton]
 * Whether the service is a singleton or not
 * @param  {any} [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new provider initializer
 * @example
 *
 * import Knifecycle, { provider } from 'knifecycle'
 * import fs from 'fs';
 *
 * const $ = new Knifecycle();
 *
 * $.register(provider(configProvider, 'config'));
 *
 * async function configProvider() {
 *   return new Promise((resolve, reject) {
 *     fs.readFile('config.js', function(err, data) {
 *       let config;
 *
 *       if(err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       try {
 *         config = JSON.parse(data.toString);
 *       } catch (err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       resolve({
 *         service: config,
 *       });
 *     });
 *   });
 * }
 */


function provider(providerBuilder, name, dependencies, singleton, extra) {
  if (!providerBuilder) {
    throw new _yerror.default('E_NO_PROVIDER_BUILDER');
  }

  name = name || providerBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
  dependencies = dependencies || providerBuilder[SPECIAL_PROPS.INJECT] || [];
  singleton = typeof singleton === 'undefined' ? providerBuilder[SPECIAL_PROPS.SINGLETON] || false : singleton;
  extra = extra || providerBuilder[SPECIAL_PROPS.EXTRA] || [];
  debug(`Created an initializer from a provider builder: ${name || 'anonymous'}.`);
  const uniqueInitializer = reuseSpecialProps(providerBuilder, providerBuilder, {
    [SPECIAL_PROPS.TYPE]: 'provider',
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.SINGLETON]: singleton,
    [SPECIAL_PROPS.EXTRA]: extra
  });
  return uniqueInitializer;
}
/**
 * Decorator that creates an initializer from a provider
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   providerBuilder
 * An async function to build the service provider
 * @return {Function}
 * Returns a new provider initializer
 */


function autoProvider(providerBuilder) {
  const name = readFunctionName(providerBuilder);
  const source = providerBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return provider(providerBuilder, name, dependencies);
}
/**
 * Allows to wrap an initializer to add extra initialization steps
 * @param  {Function} wrapper
 * A function taking dependencies and the base
 * service in arguments
 * @param  {Function} baseInitializer
 * The initializer to decorate
 * @return {Function}
 * The new initializer
 */


function wrapInitializer(wrapper, baseInitializer) {
  return reuseSpecialProps(baseInitializer, async services => {
    const baseInstance = await baseInitializer(services);
    return wrapper(services, baseInstance);
  });
}
/**
 * Decorator creating a new initializer with different
 *  dependencies declarations set to it.
 * @param  {Array<String>}  dependencies
 * List of dependencies declarations to declare which
 *  services the initializer needs to provide its
 *  own service
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { inject } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 *  .register(
 *    service(
 *      inject(['ENV'], myServiceInitializer)
 *      'myService',
 *    )
 *   )
 * );
 */


function inject(dependencies, initializer) {
  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {
    throw new _yerror.default(E_BAD_INJECT_IN_CONSTANT, initializer[SPECIAL_PROPS.NAME], dependencies);
  }

  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.INJECT]: dependencies
  });
  debug('Wrapped an initializer with dependencies:', dependencies);
  return uniqueInitializer;
}
/**
 * Apply injected dependencies from the given initializer to another one
 * @param  {Function} from The initialization function in which to pick the dependencies
 * @param  {Function} to   The destination initialization function
 * @return {Function}      The newly built initialization function
 */


function useInject(from, to) {
  return inject(from[SPECIAL_PROPS.INJECT] || [], to);
}
/**
 * Merge injected dependencies of the given initializer with another one
 * @param  {Function} from The initialization function in which to pick the dependencies
 * @param  {Function} to   The destination initialization function
 * @return {Function}      The newly built initialization function
 */


function mergeInject(from, to) {
  return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);
}
/**
 * Decorator creating a new initializer with different
 *  dependencies declarations set to it according to the
 *  given function signature.
 * @param  {Function}  initializer
 * The original initializer
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { autoInject, name } from 'knifecycle'
 *
 * new Knifecycle()
 *   .register(
 *     name(
 *       'application',
 *       autoInject(
 *         async ({ NODE_ENV, mysql: db }) =>
 *           async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])
 *         )
 *       )
 *     )
 *   )
 * );
 */


function autoInject(initializer) {
  const source = initializer.toString();
  const dependencies = parseInjections(source);
  return inject(dependencies, initializer);
}
/**
 * Decorator creating a new initializer with some
 *  more dependencies declarations appended to it.
 * @param  {Array<String>}  dependencies
 * List of dependencies declarations to append
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { alsoInject } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   alsoInject(['ENV'], myServiceInitializer),
 *   'myService',
 * ));
 */


function alsoInject(dependencies, initializer) {
  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(parseDependencyDeclaration);
  const addedDependencies = dependencies.map(parseDependencyDeclaration);
  const dedupedDependencies = currentDependencies.filter(({
    serviceName
  }) => {
    const declarationIsOverridden = addedDependencies.some(({
      serviceName: addedServiceName
    }) => {
      return addedServiceName === serviceName;
    });
    return !declarationIsOverridden;
  }).concat(addedDependencies.map(({
    serviceName,
    mappedName,
    optional
  }) => {
    const isOptionalEverywhere = optional && currentDependencies.every(({
      optional,
      mappedName: addedMappedName
    }) => {
      return addedMappedName !== mappedName || optional;
    });
    return {
      serviceName,
      mappedName,
      optional: isOptionalEverywhere
    };
  })).map(stringifyDependencyDeclaration);
  return inject(dedupedDependencies, initializer);
}
/**
 * Decorator creating a new initializer with some
 *  extra informations appended to it. It is just
 *  a way for user to store some additional
 *  informations but has no interaction with the
 *  Knifecycle internals.
 * @param  {Object}  extraInformations
 * An object containing those extra informations.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @param  {Boolean}   [merge=false]
 * Whether the extra object should be merged
 * with the existing one or not
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { extra } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   extra({ httpHandler: true }, myServiceInitializer),
 *   'myService',
 * ));
 */


function extra(extraInformations, initializer, merge = false) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.EXTRA]: merge ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations) : extraInformations
  });
  debug('Wrapped an initializer with extra informations:', extraInformations);
  return uniqueInitializer;
}
/**
 * Decorator to set an initializer singleton option.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @param  {boolean}    [isSingleton=true]
 * Define the initializer singleton option
 * (one instance for several runs if true)
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { inject, singleton } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   inject(['ENV'],
 *     singleton(myServiceInitializer)
 *   ),
 *   'myService',
 * ));
 */


function singleton(initializer, isSingleton = true) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.SINGLETON]: isSingleton
  });
  debug('Marked an initializer as singleton:', isSingleton);
  return uniqueInitializer;
}
/**
 * Decorator to set an initializer name.
 * @param  {String}    name
 * The name of the service the initializer resolves to.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer with that name set
 * @example
 *
 * import Knifecycle, { name } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(name('myService', myServiceInitializer));
 */


function name(name, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.NAME]: name
  });
  debug('Wrapped an initializer with a name:', name);
  return uniqueInitializer;
}
/**
 * Decorator to set an initializer name from its function name.
 * @param  {Function}  initializer
 * The initializer to name
 * @return {Function}
 * Returns a new initializer with that name set
 * @example
 *
 * import Knifecycle, { autoName } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(autoName(async function myService() {}));
 */


function autoName(initializer) {
  return name(readFunctionName(initializer), initializer);
}
/**
 * Decorator to set an initializer type.
 * @param  {String}    type
 * The type to set to the initializer.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { name, type } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(
 *   type('service',
 *     name('myService',
 *       myServiceInitializer
 *     )
 *   )
 * );
 */


function type(type, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.TYPE]: type
  });
  debug('Wrapped an initializer with a type:', type);
  return uniqueInitializer;
}
/**
 * Decorator to set an initializer properties.
 * @param  {Object}    properties
 * Properties to set to the service.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { initializer } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(initializer({
 *   name: 'myService',
 *   type: 'service',
 *   inject: ['ENV'],
 *   singleton: true,
 * }, myServiceInitializer));
 */


function initializer(properties, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, Object.keys(properties).reduce((finalProperties, property) => {
    const finalProperty = SPECIAL_PROPS_PREFIX + property;

    if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {
      throw new _yerror.default('E_BAD_PROPERTY', property);
    }

    finalProperties[finalProperty] = properties[property];
    return finalProperties;
  }, {}));
  debug('Wrapped an initializer with properties:', properties);
  return uniqueInitializer;
}
/**
 * Shortcut to create an initializer with a simple handler
 * @param  {Function} handlerFunction
 * The handler function
 * @param  {String}  [name]
 * The name of the handler. Default to the DI prop if exists
 * @param  {Array<String>}  [dependencies=[]]
 * The dependencies to inject in it
 * @param  {Object}    [options]
 * Options attached to the built initializer
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { handler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(handler(getUser, 'getUser', ['db', '?log']));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */


function handler(handlerFunction, name, dependencies, singleton, extra) {
  name = name || handlerFunction[SPECIAL_PROPS.NAME];
  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT] || [];

  if (!name) {
    throw new _yerror.default('E_NO_HANDLER_NAME', handlerFunction);
  }

  return initializer({
    name,
    type: 'service',
    inject: dependencies,
    singleton,
    extra
  }, async (...args) => handlerFunction.bind(null, ...args));
}
/**
 * Allows to create an initializer with a simple handler automagically
 * @param  {Function} handlerFunction
 * The handler function
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { autoHandler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(autoHandler(getUser));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */


function autoHandler(handlerFunction) {
  const name = readFunctionName(handlerFunction);
  const source = handlerFunction.toString();
  const dependencies = parseInjections(source);
  return initializer({
    name,
    type: 'service',
    inject: dependencies
  }, async (...args) => handlerFunction.bind(null, ...args));
}
/* Architecture Note #1.2.1: Dependencies declaration syntax

The dependencies syntax is of the following form:
 `?serviceName>mappedName`
The `?` flag indicates an optional dependency.
 `>mappedName` is optional and allows to inject
 `mappedName` as `serviceName`.
It allows to write generic services with fixed
 dependencies and remap their name at injection time.
*/

/**
 * Explode a dependency declaration an returns its parts.
 * @param  {String}  dependencyDeclaration
 * A dependency declaration string
 * @return {Object}
 * The various parts of it
 * @example
 * parseDependencyDeclaration('pgsql>db');
 * // Returns
 * {
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * }
 */


function parseDependencyDeclaration(dependencyDeclaration) {
  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);
  const [serviceName, mappedName] = (optional ? dependencyDeclaration.slice(1) : dependencyDeclaration).split(DECLARATION_SEPARATOR);
  return {
    serviceName,
    mappedName: mappedName || serviceName,
    optional
  };
}
/**
 * Stringify a dependency declaration from its parts.
 * @param  {Object}  dependencyDeclarationParts
 * A dependency declaration string
 * @return {String}
 * The various parts of it
 * @example
 * stringifyDependencyDeclaration({
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * });
 *
 * // Returns
 * 'pgsql>db'
 */


function stringifyDependencyDeclaration(dependencyDeclarationParts) {
  return `${dependencyDeclarationParts.optional ? '?' : ''}${dependencyDeclarationParts.serviceName}${dependencyDeclarationParts.mappedName !== dependencyDeclarationParts.serviceName ? '>' + dependencyDeclarationParts.mappedName : ''}`;
}
/* Architecture Note #3: TypeScript tweaks

Sadly TypeScript does not allow to add generic types
 in all cases. This is why `(Service|Provider)Initializer`
 types do not embed the `(Service|Provider)Properties`
 direclty. Instead, we use this utility function to
 reveal it to TypeScript and, by the way, check their
 completeness at execution time.

For more details, see:
https://stackoverflow.com/questions/64948037/generics-type-loss-while-infering/64950184#64950184
*/

/**
 * Utility function to check and reveal initializer properties.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns revealed initializer (with TypeScript types for properties)
 */


function unwrapInitializerProperties(initializer) {
  if (typeof initializer !== 'function' && typeof initializer !== 'object') {
    throw new _yerror.default('E_BAD_INITIALIZER', initializer);
  }

  const properties = initializer;

  if (typeof properties[SPECIAL_PROPS.NAME] !== 'string' || properties[SPECIAL_PROPS.NAME] === '') {
    throw new _yerror.default('E_ANONYMOUS_ANALYZER', properties[SPECIAL_PROPS.NAME]);
  }

  if (!ALLOWED_INITIALIZER_TYPES.includes(properties[SPECIAL_PROPS.TYPE])) {
    throw new _yerror.default('E_BAD_INITIALIZER_TYPE', initializer[SPECIAL_PROPS.NAME], initializer[SPECIAL_PROPS.TYPE], ALLOWED_INITIALIZER_TYPES);
  }

  if (initializer[SPECIAL_PROPS.NAME] === '$autoload' && !initializer[SPECIAL_PROPS.SINGLETON]) {
    throw new _yerror.default('E_BAD_AUTOLOADER', initializer[SPECIAL_PROPS.SINGLETON] || false);
  }

  if (properties[SPECIAL_PROPS.TYPE] === 'constant') {
    if ('undefined' === typeof initializer[SPECIAL_PROPS.VALUE]) {
      throw new _yerror.default('E_UNDEFINED_CONSTANT_INITIALIZER', properties[SPECIAL_PROPS.NAME]);
    }

    properties[SPECIAL_PROPS.SINGLETON] = true;
  } else {
    if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {
      throw new _yerror.default('E_BAD_VALUED_NON_CONSTANT_INITIALIZER', initializer[SPECIAL_PROPS.NAME]);
    }

    properties[SPECIAL_PROPS.INJECT] = properties[SPECIAL_PROPS.INJECT] || [];
    properties[SPECIAL_PROPS.SINGLETON] = properties[SPECIAL_PROPS.SINGLETON] || false;
    properties[SPECIAL_PROPS.EXTRA] = properties[SPECIAL_PROPS.EXTRA] || undefined;
  }

  return initializer;
}
//# sourceMappingURL=util.js.map