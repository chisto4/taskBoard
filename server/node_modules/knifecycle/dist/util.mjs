import YError from 'yerror';
import initDebug from 'debug';
const debug = initDebug('knifecycle');
export const DECLARATION_SEPARATOR = '>';
export const OPTIONAL_FLAG = '?';
export const ALLOWED_INITIALIZER_TYPES = ['provider', 'service', 'constant'];
export const SPECIAL_PROPS_PREFIX = '$';
export const SPECIAL_PROPS = {
  TYPE: `${SPECIAL_PROPS_PREFIX}type`,
  NAME: `${SPECIAL_PROPS_PREFIX}name`,
  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,
  SINGLETON: `${SPECIAL_PROPS_PREFIX}singleton`,
  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,
  VALUE: `${SPECIAL_PROPS_PREFIX}value`
};
export const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(key => SPECIAL_PROPS[key]);
const E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';
const E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';
export function parseInjections(source, options) {
  const matches = source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\{\s*([^{}]+)(\s*\.\.\.[^{}]+|)\s*\}/);

  if (!matches) {
    if (!source.match(/^\s*async/)) {
      throw new YError('E_NON_ASYNC_INITIALIZER', source);
    }

    if (options && options.allowEmpty && source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\)/)) {
      return [];
    }

    throw new YError('E_AUTO_INJECTION_FAILURE', source);
  }

  return matches[1].trim().replace(/,$/, '').split(/\s*,\s*/).map(s => s.trim()).filter(s => !s.startsWith('...')).map(injection => (injection.includes('=') ? '?' : '') + injection.split(/\s*=\s*/).shift().split(/\s*:\s*/).shift()).filter(injection => !/[)(\][]/.test(injection));
}
export function readFunctionName(aFunction) {
  if (typeof aFunction !== 'function') {
    throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);
  }

  const functionName = parseName(aFunction.name || '');

  if (!functionName) {
    throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);
  }

  return functionName;
}
export function parseName(functionName) {
  return functionName.split(' ').pop().replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());
}
export function reuseSpecialProps(from, to, amend = {}) {
  const uniqueInitializer = to.bind(null);
  return [...new Set(Object.keys(from).concat(Object.keys(amend)))].filter(prop => prop.startsWith(SPECIAL_PROPS_PREFIX)).reduce((fn, prop) => {
    const value = 'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];

    if (value instanceof Array) {
      fn[prop] = value.concat();
    } else if (value instanceof Object) {
      fn[prop] = Object.assign({}, value);
    } else {
      fn[prop] = value;
    }

    return fn;
  }, uniqueInitializer);
}
export function constant(name, value) {
  const contantLooksLikeAnInitializer = value instanceof Function && value[SPECIAL_PROPS.INJECT];

  if (contantLooksLikeAnInitializer) {
    throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);
  }

  debug(`Created an initializer from a constant: ${name}.`);
  return {
    $type: 'constant',
    $name: name,
    $singleton: true,
    $value: value
  };
}
export function service(serviceBuilder, name, dependencies, singleton, extra) {
  if (!serviceBuilder) {
    throw new YError('E_NO_SERVICE_BUILDER');
  }

  name = name || serviceBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
  dependencies = dependencies || serviceBuilder[SPECIAL_PROPS.INJECT] || [];
  singleton = typeof singleton === 'undefined' ? serviceBuilder[SPECIAL_PROPS.SINGLETON] || false : singleton;
  extra = extra || serviceBuilder[SPECIAL_PROPS.EXTRA] || [];
  debug(`Created an initializer from a service builder: ${name}.`);
  const uniqueInitializer = reuseSpecialProps(serviceBuilder, serviceBuilder, {
    [SPECIAL_PROPS.TYPE]: 'service',
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.SINGLETON]: singleton,
    [SPECIAL_PROPS.EXTRA]: extra
  });
  return uniqueInitializer;
}
export function autoService(serviceBuilder) {
  const name = readFunctionName(serviceBuilder);
  const source = serviceBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return service(serviceBuilder, name, dependencies);
}
export function provider(providerBuilder, name, dependencies, singleton, extra) {
  if (!providerBuilder) {
    throw new YError('E_NO_PROVIDER_BUILDER');
  }

  name = name || providerBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
  dependencies = dependencies || providerBuilder[SPECIAL_PROPS.INJECT] || [];
  singleton = typeof singleton === 'undefined' ? providerBuilder[SPECIAL_PROPS.SINGLETON] || false : singleton;
  extra = extra || providerBuilder[SPECIAL_PROPS.EXTRA] || [];
  debug(`Created an initializer from a provider builder: ${name || 'anonymous'}.`);
  const uniqueInitializer = reuseSpecialProps(providerBuilder, providerBuilder, {
    [SPECIAL_PROPS.TYPE]: 'provider',
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.SINGLETON]: singleton,
    [SPECIAL_PROPS.EXTRA]: extra
  });
  return uniqueInitializer;
}
export function autoProvider(providerBuilder) {
  const name = readFunctionName(providerBuilder);
  const source = providerBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return provider(providerBuilder, name, dependencies);
}
export function wrapInitializer(wrapper, baseInitializer) {
  return reuseSpecialProps(baseInitializer, async services => {
    const baseInstance = await baseInitializer(services);
    return wrapper(services, baseInstance);
  });
}
export function inject(dependencies, initializer) {
  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {
    throw new YError(E_BAD_INJECT_IN_CONSTANT, initializer[SPECIAL_PROPS.NAME], dependencies);
  }

  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.INJECT]: dependencies
  });
  debug('Wrapped an initializer with dependencies:', dependencies);
  return uniqueInitializer;
}
export function useInject(from, to) {
  return inject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function mergeInject(from, to) {
  return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function autoInject(initializer) {
  const source = initializer.toString();
  const dependencies = parseInjections(source);
  return inject(dependencies, initializer);
}
export function alsoInject(dependencies, initializer) {
  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(parseDependencyDeclaration);
  const addedDependencies = dependencies.map(parseDependencyDeclaration);
  const dedupedDependencies = currentDependencies.filter(({
    serviceName
  }) => {
    const declarationIsOverridden = addedDependencies.some(({
      serviceName: addedServiceName
    }) => {
      return addedServiceName === serviceName;
    });
    return !declarationIsOverridden;
  }).concat(addedDependencies.map(({
    serviceName,
    mappedName,
    optional
  }) => {
    const isOptionalEverywhere = optional && currentDependencies.every(({
      optional,
      mappedName: addedMappedName
    }) => {
      return addedMappedName !== mappedName || optional;
    });
    return {
      serviceName,
      mappedName,
      optional: isOptionalEverywhere
    };
  })).map(stringifyDependencyDeclaration);
  return inject(dedupedDependencies, initializer);
}
export function extra(extraInformations, initializer, merge = false) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.EXTRA]: merge ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations) : extraInformations
  });
  debug('Wrapped an initializer with extra informations:', extraInformations);
  return uniqueInitializer;
}
export function singleton(initializer, isSingleton = true) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.SINGLETON]: isSingleton
  });
  debug('Marked an initializer as singleton:', isSingleton);
  return uniqueInitializer;
}
export function name(name, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.NAME]: name
  });
  debug('Wrapped an initializer with a name:', name);
  return uniqueInitializer;
}
export function autoName(initializer) {
  return name(readFunctionName(initializer), initializer);
}
export function type(type, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.TYPE]: type
  });
  debug('Wrapped an initializer with a type:', type);
  return uniqueInitializer;
}
export function initializer(properties, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, Object.keys(properties).reduce((finalProperties, property) => {
    const finalProperty = SPECIAL_PROPS_PREFIX + property;

    if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {
      throw new YError('E_BAD_PROPERTY', property);
    }

    finalProperties[finalProperty] = properties[property];
    return finalProperties;
  }, {}));
  debug('Wrapped an initializer with properties:', properties);
  return uniqueInitializer;
}
export function handler(handlerFunction, name, dependencies, singleton, extra) {
  name = name || handlerFunction[SPECIAL_PROPS.NAME];
  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT] || [];

  if (!name) {
    throw new YError('E_NO_HANDLER_NAME', handlerFunction);
  }

  return initializer({
    name,
    type: 'service',
    inject: dependencies,
    singleton,
    extra
  }, async (...args) => handlerFunction.bind(null, ...args));
}
export function autoHandler(handlerFunction) {
  const name = readFunctionName(handlerFunction);
  const source = handlerFunction.toString();
  const dependencies = parseInjections(source);
  return initializer({
    name,
    type: 'service',
    inject: dependencies
  }, async (...args) => handlerFunction.bind(null, ...args));
}
export function parseDependencyDeclaration(dependencyDeclaration) {
  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);
  const [serviceName, mappedName] = (optional ? dependencyDeclaration.slice(1) : dependencyDeclaration).split(DECLARATION_SEPARATOR);
  return {
    serviceName,
    mappedName: mappedName || serviceName,
    optional
  };
}
export function stringifyDependencyDeclaration(dependencyDeclarationParts) {
  return `${dependencyDeclarationParts.optional ? '?' : ''}${dependencyDeclarationParts.serviceName}${dependencyDeclarationParts.mappedName !== dependencyDeclarationParts.serviceName ? '>' + dependencyDeclarationParts.mappedName : ''}`;
}
export function unwrapInitializerProperties(initializer) {
  if (typeof initializer !== 'function' && typeof initializer !== 'object') {
    throw new YError('E_BAD_INITIALIZER', initializer);
  }

  const properties = initializer;

  if (typeof properties[SPECIAL_PROPS.NAME] !== 'string' || properties[SPECIAL_PROPS.NAME] === '') {
    throw new YError('E_ANONYMOUS_ANALYZER', properties[SPECIAL_PROPS.NAME]);
  }

  if (!ALLOWED_INITIALIZER_TYPES.includes(properties[SPECIAL_PROPS.TYPE])) {
    throw new YError('E_BAD_INITIALIZER_TYPE', initializer[SPECIAL_PROPS.NAME], initializer[SPECIAL_PROPS.TYPE], ALLOWED_INITIALIZER_TYPES);
  }

  if (initializer[SPECIAL_PROPS.NAME] === '$autoload' && !initializer[SPECIAL_PROPS.SINGLETON]) {
    throw new YError('E_BAD_AUTOLOADER', initializer[SPECIAL_PROPS.SINGLETON] || false);
  }

  if (properties[SPECIAL_PROPS.TYPE] === 'constant') {
    if ('undefined' === typeof initializer[SPECIAL_PROPS.VALUE]) {
      throw new YError('E_UNDEFINED_CONSTANT_INITIALIZER', properties[SPECIAL_PROPS.NAME]);
    }

    properties[SPECIAL_PROPS.SINGLETON] = true;
  } else {
    if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {
      throw new YError('E_BAD_VALUED_NON_CONSTANT_INITIALIZER', initializer[SPECIAL_PROPS.NAME]);
    }

    properties[SPECIAL_PROPS.INJECT] = properties[SPECIAL_PROPS.INJECT] || [];
    properties[SPECIAL_PROPS.SINGLETON] = properties[SPECIAL_PROPS.SINGLETON] || false;
    properties[SPECIAL_PROPS.EXTRA] = properties[SPECIAL_PROPS.EXTRA] || undefined;
  }

  return initializer;
}
//# sourceMappingURL=util.mjs.map