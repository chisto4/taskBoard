{"version":3,"sources":["../src/build.ts"],"names":["SPECIAL_PROPS","parseDependencyDeclaration","initializer","buildInitializationSequence","name","type","inject","initInitializerBuilder","$autoload","buildInitializer","dependencies","options","dependencyTrees","Promise","all","map","dependency","buildDependencyTree","dependenciesHash","buildDependenciesHash","filter","identity","batches","__name","__childNodes","pop","batch","index","__initializer","TYPE","JSON","stringify","VALUE","modules","__initializerName","__path","join","__inject","serviceName","mappedName","__type","dependencyDeclaration","optional","path","node","INJECT","upperCaseFirst","length","childNodes","childDependencyDeclaration","err","hash","reduce","tree","buildHashFromNode","nodeIsALeaf","forEach","childNode","a","str","toUpperCase","slice"],"mappings":"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","sourcesContent":["import { SPECIAL_PROPS, parseDependencyDeclaration, initializer } from './util';\nimport { buildInitializationSequence } from './sequence';\nimport type { DependencyDeclaration } from './util';\nimport type { Autoloader } from '.';\n\nexport type BuildOptions = { modules?: 'commonjs' | true };\nexport type BuildInitializer = (\n  dependencies: DependencyDeclaration[],\n  options?: BuildOptions,\n) => Promise<string>;\n\n/* Architecture Note #2: Build\n\nUsing Knifecycle only makes sense for\n monoliths. For some targets like\n serverless functions, a better\n approach is to simply build a raw\n initialization function.\n\nFor the build to work, we need:\n- a hash of various constants that may be\n used.\n- an autoloader that resolves dependencies\n names to its actual initializer\n- the dependencies list you want to\n initialize\n*/\n\nexport default initializer(\n  {\n    name: 'buildInitializer',\n    type: 'service',\n    inject: ['$autoload'],\n  },\n  initInitializerBuilder,\n);\n\n/**\n * Instantiate the initializer builder service\n * @param  {Object}   services\n * The services to inject\n * @param  {Object}   services.$autoload\n * The dependencies autoloader\n * @return {Promise<Function>}\n * A promise of the buildInitializer function\n * @example\n * import initInitializerBuilder from 'knifecycle/dist/build';\n *\n * const buildInitializer = await initInitializerBuilder({\n *   $autoload: async () => {},\n * });\n */\nasync function initInitializerBuilder({\n  $autoload,\n}: {\n  $autoload: Autoloader;\n}) {\n  return buildInitializer;\n\n  /**\n   * Create a JavaScript module that initialize\n   * a set of dependencies with hardcoded\n   * import/awaits.\n   * @param  {String[]} dependencies\n   * The main dependencies\n   * @return {Promise<String>}\n   * The JavaScript module content\n   * @example\n   * import initInitializerBuilder from 'knifecycle/dist/build';\n   *\n   * const buildInitializer = await initInitializerBuilder({\n   *   $autoload: async () => {},\n   * });\n   *\n   * const content = await buildInitializer(['entryPoint']);\n   */\n  async function buildInitializer(\n    dependencies: DependencyDeclaration[],\n    options: BuildOptions = {},\n  ): Promise<string> {\n    const dependencyTrees = await Promise.all(\n      dependencies.map((dependency) =>\n        buildDependencyTree({ $autoload }, dependency),\n      ),\n    );\n    const dependenciesHash = buildDependenciesHash(\n      dependencyTrees.filter(identity),\n    );\n    const batches = buildInitializationSequence({\n      __name: 'main',\n      __childNodes: dependencyTrees.filter(identity),\n    });\n    batches.pop();\n\n    return `${batches\n      .map(\n        (batch, index) => `\n// Definition batch #${index}${batch\n          .map((name) => {\n            if (\n              'constant' ===\n              dependenciesHash[name].__initializer[SPECIAL_PROPS.TYPE]\n            ) {\n              return `\nconst ${name} = ${JSON.stringify(\n                dependenciesHash[name].__initializer[SPECIAL_PROPS.VALUE],\n                null,\n                2,\n              )};`;\n            }\n\n            return options.modules === 'commonjs'\n              ? `\nconst ${dependenciesHash[name].__initializerName} = (() => { const m = require('${dependenciesHash[name].__path}'); return m && m.default || m; })();`\n              : `\nimport ${dependenciesHash[name].__initializerName} from '${dependenciesHash[name].__path}';`;\n          })\n          .join('')}`,\n      )\n      .join('\\n')}\n\n${\n  options.modules === 'commonjs'\n    ? 'module.exports = {}; module.exports.initialize = '\n    : 'export '\n}async function initialize(services = {}) {${batches\n      .map(\n        (batch, index) => `\n  // Initialization batch #${index}\n  const batch${index} = {${batch\n          .map((name) => {\n            if (\n              'constant' ===\n              dependenciesHash[name].__initializer[SPECIAL_PROPS.TYPE]\n            ) {\n              return `\n    ${name}: Promise.resolve(${name}),`;\n            }\n            return `\n    ${name}: ${dependenciesHash[name].__initializerName}({${\n              dependenciesHash[name].__inject\n                ? `${dependenciesHash[name].__inject\n                    .map(parseDependencyDeclaration)\n                    .map(\n                      ({ serviceName, mappedName }) =>\n                        `\n      ${serviceName}: services['${mappedName}'],`,\n                    )\n                    .join('')}`\n                : ''\n            }\n    })${\n      'provider' === dependenciesHash[name].__type\n        ? '.then(provider => provider.service)'\n        : ''\n    },`;\n          })\n          .join('')}\n  };\n\n  await Promise.all(\n    Object.keys(batch${index})\n    .map(key => batch${index}[key])\n  );\n${batch\n  .map((name) => {\n    return `\n  services['${name}'] = await batch${index}['${name}'];`;\n  })\n  .join('')}\n`,\n      )\n      .join('')}\n  return {${dependencies\n    .map(parseDependencyDeclaration)\n    .map(\n      ({ serviceName, mappedName }) =>\n        `\n    ${serviceName}: services['${mappedName}'],`,\n    )\n    .join('')}\n  };\n}\n`;\n  }\n}\n\nasync function buildDependencyTree({ $autoload }, dependencyDeclaration) {\n  const { mappedName, optional } = parseDependencyDeclaration(\n    dependencyDeclaration,\n  );\n\n  try {\n    const { path, initializer } = await $autoload(mappedName);\n    const node = {\n      __name: mappedName,\n      __initializer: initializer,\n      __inject:\n        initializer && initializer[SPECIAL_PROPS.INJECT]\n          ? initializer[SPECIAL_PROPS.INJECT]\n          : [],\n      __type:\n        initializer && initializer[SPECIAL_PROPS.TYPE]\n          ? initializer[SPECIAL_PROPS.TYPE]\n          : 'provider',\n      __initializerName: 'init' + upperCaseFirst(mappedName),\n      __path: path,\n      __childNodes: [],\n    };\n\n    if (\n      initializer[SPECIAL_PROPS.INJECT] &&\n      initializer[SPECIAL_PROPS.INJECT].length\n    ) {\n      const childNodes = await Promise.all(\n        initializer[SPECIAL_PROPS.INJECT].map((childDependencyDeclaration) =>\n          buildDependencyTree({ $autoload }, childDependencyDeclaration),\n        ),\n      );\n      node.__childNodes = childNodes.filter(identity);\n      return node;\n    } else {\n      return node;\n    }\n  } catch (err) {\n    if (optional) {\n      return null;\n    }\n    throw err;\n  }\n}\n\nfunction buildDependenciesHash(dependencyTrees, hash = {}) {\n  return dependencyTrees.reduce(\n    (hash, tree) => buildHashFromNode(tree, hash),\n    hash,\n  );\n}\n\nfunction buildHashFromNode(node, hash = {}) {\n  const nodeIsALeaf = !(node.__childNodes && node.__childNodes.length);\n\n  hash[node.__name] = node;\n\n  if (nodeIsALeaf) {\n    return hash;\n  }\n\n  node.__childNodes.forEach((childNode) => {\n    hash = buildHashFromNode(childNode, hash);\n  });\n\n  return hash;\n}\n\nfunction identity(a) {\n  return a;\n}\n\nfunction upperCaseFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n"],"file":"build.mjs"}