import { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, reuseSpecialProps, parseName, name, autoName, inject, useInject, mergeInject, autoInject, alsoInject, type, extra, singleton, initializer, constant, service, autoService, provider, autoProvider, wrapInitializer, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties } from './util';
import initInitializerBuilder from './build';
import type { ServiceName, Service, Disposer, FatalErrorProvider, Provider, Dependencies, DependencyName, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, Parameters, HandlerFunction } from './util';
import type { BuildInitializer } from './build';
export type { ServiceName, Service, Disposer, FatalErrorProvider, Provider, Dependencies, DependencyName, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, Parameters, HandlerFunction, BuildInitializer, };
export interface Injector<S extends Service> {
    (dependencies: DependencyDeclaration[]): Promise<Dependencies<S>>;
}
export interface Autoloader<S extends Service = Service> {
    (name: DependencyDeclaration): Promise<{
        initializer: Initializer<S, Dependencies<S>>;
        path: string;
    }>;
}
export interface SiloContext<S extends Service> {
    name: string;
    servicesDescriptors: Map<DependencyDeclaration, Promise<Provider<S>>>;
    servicesSequence: DependencyDeclaration[][];
    servicesShutdownsPromises: Map<DependencyDeclaration, Promise<void>>;
    errorsPromises: Promise<void>[];
    shutdownPromise?: Promise<void>;
    throwFatalError?: (err: Error) => void;
}
export declare type FatalErrorService = {
    promise: Promise<void>;
};
export declare type InternalDependencies<D extends Dependencies> = {
    $dispose: Disposer;
    $autoload: Autoloader<D[string]>;
    $injector: Injector<D>;
    $instance: Knifecycle<D>;
    $siloContext: SiloContext<D[string]>;
    $fatalError: FatalErrorService;
} & D;
declare class Knifecycle<D extends Dependencies, AD extends InternalDependencies<D> = InternalDependencies<D>, AS extends Service = AD[string]> {
    private _silosCounter;
    private _silosContexts;
    private _initializers;
    private _initializerResolvers;
    private _singletonsServicesHandles;
    private _singletonsServicesDescriptors;
    private _singletonsServicesShutdownsPromises;
    private shutdownPromise;
    /**
     * Create a new Knifecycle instance
     * @return {Knifecycle}
     * The Knifecycle instance
     * @example
     *
     * import Knifecycle from 'knifecycle'
     *
     * const $ = new Knifecycle();
     */
    constructor();
    /**
     * Register an initializer
     * @param  {Function}   initializer
     * An initializer
     * @return {Knifecycle}
     * The Knifecycle instance (for chaining)
     */
    register(initializer: Initializer<AS, Dependencies<AS>>): Knifecycle<D, AD, AS>;
    _lookupCircularDependencies(rootServiceName: ServiceName, dependencyDeclaration: DependencyDeclaration, declarationsStacks?: DependencyDeclaration[]): void;
    /**
     * Outputs a Mermaid compatible dependency graph of the declared services.
     * See [Mermaid docs](https://github.com/knsv/mermaid)
     * @param {Object} options
     * Options for generating the graph (destructured)
     * @param {Array<Object>} options.shapes
     * Various shapes to apply
     * @param {Array<Object>} options.styles
     * Various styles to apply
     * @param {Object} options.classes
     * A hash of various classes contents
     * @return {String}
     * Returns a string containing the Mermaid dependency graph
     * @example
     *
     * import Knifecycle, { inject, constant, service } from 'knifecycle';
     * import appInitializer from './app';
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.register(constant('OS', require('os')));
     * $.register(service('app', inject(['ENV', 'OS'], appInitializer)));
     * $.toMermaidGraph();
     *
     * // returns
     * graph TD
     *   app-->ENV
     *   app-->OS
     */
    toMermaidGraph({ shapes, styles, classes, }?: {
        shapes: {
            pattern: RegExp;
            template: string;
        }[];
        styles: {
            pattern: RegExp;
            className: string;
        }[];
        classes: {
            [name: string]: string;
        };
    }): string;
    /**
     * Creates a new execution silo
     * @param  {String[]}   dependenciesDeclarations
     * Service name.
     * @return {Promise}
     * Service descriptor promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *  // Here goes your code
     * })
     */
    run<ID extends Partial<AD> = AD>(dependenciesDeclarations: DependencyDeclaration[]): Promise<ID>;
    /**
     * Destroy the Knifecycle instance
     * @return {Promise}
     * Full destruction promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *    // Here goes your code
     *
     *    // Finally destroy the instance
     *    $.destroy()
     * })
     */
    destroy(): Promise<void>;
    /**
     * Initialize or return a service descriptor
     * @param  {Object}     siloContext
     * Current execution silo context
     * @param  {String}     serviceName
     * Service name.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependencies on the fly loading
     * @param  {String}     serviceProvider
     * Service provider.
     * @return {Promise}
     * Service descriptor promise.
     */
    _getServiceDescriptor(siloContext: SiloContext<AS>, serviceName: ServiceName, { injectorContext, autoloading, }: {
        injectorContext: boolean;
        autoloading: boolean;
    }): Promise<Provider<AS>>;
    _findInitializer(siloContext: SiloContext<AS>, serviceName: ServiceName, { injectorContext, autoloading, }: {
        injectorContext: boolean;
        autoloading: boolean;
    }): Promise<ProviderInitializer<Dependencies<AS>, AS>>;
    _pickupSingletonServiceDescriptorPromise(serviceName: ServiceName): Promise<Provider<AS>>;
    /**
     * Initialize a service descriptor
     * @param  {Object}     siloContext
     * Current execution silo context
     * @param  {String}     serviceName
     * Service name.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependendencies on the fly loading.
     * @return {Promise}
     * Service dependencies hash promise.
     */
    _initializeServiceDescriptor(siloContext: SiloContext<AS>, serviceName: ServiceName, initializer: ProviderInitializer<Dependencies<AS>, AS>, { autoloading, injectorContext, }: {
        autoloading: boolean;
        injectorContext: boolean;
    }): Promise<Provider<AS>>;
    /**
     * Initialize a service dependencies
     * @param  {Object}     siloContext
     * Current execution silo siloContext
     * @param  {String}     serviceName
     * Service name.
     * @param  {String}     servicesDeclarations
     * Dependencies declarations.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependendencies on the fly loading.
     * @return {Promise}
     * Service dependencies hash promise.
     */
    _initializeDependencies(siloContext: SiloContext<AS>, serviceName: ServiceName, servicesDeclarations: DependencyDeclaration[], { injectorContext, autoloading, }: {
        autoloading: boolean;
        injectorContext: boolean;
    }): Promise<Dependencies>;
}
export default Knifecycle;
export { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, parseName, Knifecycle, initializer, name, autoName, type, inject, useInject, mergeInject, autoInject, alsoInject, extra, singleton, reuseSpecialProps, wrapInitializer, constant, service, autoService, provider, autoProvider, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties, initInitializerBuilder, };
