{"version":3,"sources":["../src/index.ts"],"names":["SPECIAL_PROPS","SPECIAL_PROPS_PREFIX","DECLARATION_SEPARATOR","OPTIONAL_FLAG","ALLOWED_INITIALIZER_TYPES","ALLOWED_SPECIAL_PROPS","parseInjections","readFunctionName","reuseSpecialProps","parseName","name","autoName","inject","useInject","mergeInject","autoInject","alsoInject","type","extra","singleton","initializer","constant","service","autoService","provider","autoProvider","wrapInitializer","handler","autoHandler","parseDependencyDeclaration","stringifyDependencyDeclaration","unwrapInitializerProperties","initInitializerBuilder","YError","initDebug","debug","DISPOSE","AUTOLOAD","INJECTOR","INSTANCE","SILO_CONTEXT","FATAL_ERROR","E_BAD_INITIALIZER_TYPE","E_BAD_AUTOLOADED_INITIALIZER","E_BAD_AUTOLOADER","E_AUTOLOADED_INITIALIZER_MISMATCH","E_UNMATCHED_DEPENDENCY","E_CIRCULAR_DEPENDENCY","E_BAD_INITIALIZER","E_ANONYMOUS_ANALYZER","E_BAD_SERVICE_PROVIDER","E_BAD_SERVICE_PROMISE","E_INSTANCE_DESTROYED","E_AUTOLOADER_DYNAMIC_DEPENDENCY","E_BAD_CLASS","E_UNDEFINED_CONSTANT_INITIALIZER","E_BAD_VALUED_NON_CONSTANT_INITIALIZER","Knifecycle","constructor","_silosCounter","_silosContexts","Set","_initializers","Map","_initializerResolvers","_singletonsServicesHandles","_singletonsServicesDescriptors","_singletonsServicesShutdownsPromises","register","initInjectorProvider","$siloContext","dependenciesDeclarations","_buildFinalHash","_initializeDependencies","injectorContext","autoloading","shutdownPromise","TYPE","value","VALUE","NAME","serviceAdapter","bind","initializerDependsOfItself","INJECT","map","_pickServiceNameFromDeclaration","includes","forEach","dependencyDeclaration","_lookupCircularDependencies","has","initializedAsSingleton","get","preloaded","initializedAsInstance","values","some","siloContext","servicesSequence","sequence","handlesSet","set","promise","rootServiceName","declarationsStacks","serviceName","dependencyProvider","concat","childDependencyDeclaration","childServiceName","toMermaidGraph","shapes","styles","classes","servicesProviders","links","Array","from","keys","filter","startsWith","reduce","serviceProvider","length","dependedServiceName","classesApplications","_applyClasses","_applyShapes","Object","className","join","run","_this","internalDependencies","servicesDescriptors","servicesShutdownsPromises","errorsPromises","Promise","resolve","reject","throwFatalError","err","_shutdownNextServices","delete","reversedServiceSequence","all","pop","singletonServiceDescriptor","_pickupSingletonServiceDescriptorPromise","serviceDescriptor","serviceShutdownPromise","servicesDeclarations","handleSet","size","dispose","add","servicesHash","catch","destroy","$dispose","then","undefined","_getServiceDescriptor","serviceDescriptorPromise","_findInitializer","_initializeServiceDescriptor","SINGLETON","unshift","initializerPromise","autoloadingDescriptor","path","finalHash","mappedName","fatalErrorPromise","push","stack","code","wrap","params","serviceDeclaration","optional","_","index","_pickMappedNameFromDeclaration","services","hash","shapedService","shape","matches","pattern","exec","template","replace","$","$1","parseInt","link","assign","_applyStyles","style","test","dependenciesHash","servicePromise","_service_"],"mappings":"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","sourcesContent":["/* eslint max-len: [\"warn\", { \"ignoreComments\": true }] @typescript-eslint/no-this-alias: \"warn\" */\nimport {\n  SPECIAL_PROPS,\n  SPECIAL_PROPS_PREFIX,\n  DECLARATION_SEPARATOR,\n  OPTIONAL_FLAG,\n  ALLOWED_INITIALIZER_TYPES,\n  ALLOWED_SPECIAL_PROPS,\n  parseInjections,\n  readFunctionName,\n  reuseSpecialProps,\n  parseName,\n  name,\n  autoName,\n  inject,\n  useInject,\n  mergeInject,\n  autoInject,\n  alsoInject,\n  type,\n  extra,\n  singleton,\n  initializer,\n  constant,\n  service,\n  autoService,\n  provider,\n  autoProvider,\n  wrapInitializer,\n  handler,\n  autoHandler,\n  parseDependencyDeclaration,\n  stringifyDependencyDeclaration,\n  unwrapInitializerProperties,\n} from './util';\nimport initInitializerBuilder from './build';\nimport YError from 'yerror';\nimport initDebug from 'debug';\nimport type {\n  ServiceName,\n  Service,\n  Disposer,\n  FatalErrorProvider,\n  Provider,\n  Dependencies,\n  DependencyName,\n  DependencyDeclaration,\n  ExtraInformations,\n  ParsedDependencyDeclaration,\n  ConstantProperties,\n  ConstantInitializer,\n  ProviderInitializerBuilder,\n  ProviderProperties,\n  ProviderInitializer,\n  ProviderInputProperties,\n  ServiceInitializerBuilder,\n  ServiceProperties,\n  ServiceInitializer,\n  ServiceInputProperties,\n  AsyncInitializerBuilder,\n  AsyncInitializer,\n  PartialAsyncInitializer,\n  Initializer,\n  ServiceInitializerWrapper,\n  ProviderInitializerWrapper,\n  Parameters,\n  HandlerFunction,\n} from './util';\nimport type { BuildInitializer } from './build';\nexport type {\n  ServiceName,\n  Service,\n  Disposer,\n  FatalErrorProvider,\n  Provider,\n  Dependencies,\n  DependencyName,\n  DependencyDeclaration,\n  ExtraInformations,\n  ParsedDependencyDeclaration,\n  ConstantProperties,\n  ConstantInitializer,\n  ProviderInitializerBuilder,\n  ProviderProperties,\n  ProviderInitializer,\n  ProviderInputProperties,\n  ServiceInitializerBuilder,\n  ServiceProperties,\n  ServiceInitializer,\n  ServiceInputProperties,\n  AsyncInitializerBuilder,\n  AsyncInitializer,\n  PartialAsyncInitializer,\n  Initializer,\n  ServiceInitializerWrapper,\n  ProviderInitializerWrapper,\n  Parameters,\n  HandlerFunction,\n  BuildInitializer,\n};\n\nexport interface Injector<S extends Service> {\n  (dependencies: DependencyDeclaration[]): Promise<Dependencies<S>>;\n}\nexport interface Autoloader<S extends Service = Service> {\n  (name: DependencyDeclaration): Promise<{\n    initializer: Initializer<S, Dependencies<S>>;\n    path: string;\n  }>;\n}\nexport interface SiloContext<S extends Service> {\n  name: string;\n  servicesDescriptors: Map<DependencyDeclaration, Promise<Provider<S>>>;\n  servicesSequence: DependencyDeclaration[][];\n  servicesShutdownsPromises: Map<DependencyDeclaration, Promise<void>>;\n  errorsPromises: Promise<void>[];\n  shutdownPromise?: Promise<void>;\n  throwFatalError?: (err: Error) => void;\n}\nexport type FatalErrorService = {\n  promise: Promise<void>;\n};\n\nexport type InternalDependencies<D extends Dependencies> = {\n  $dispose: Disposer;\n  $autoload: Autoloader<D[string]>;\n  $injector: Injector<D>;\n  $instance: Knifecycle<D>;\n  $siloContext: SiloContext<D[string]>;\n  $fatalError: FatalErrorService;\n} & D;\n\nconst debug = initDebug('knifecycle');\n\nconst DISPOSE = '$dispose';\nconst AUTOLOAD = '$autoload';\nconst INJECTOR = '$injector';\nconst INSTANCE = '$instance';\nconst SILO_CONTEXT = '$siloContext';\nconst FATAL_ERROR = '$fatalError';\n\nconst E_BAD_INITIALIZER_TYPE = 'E_BAD_INITIALIZER_TYPE';\nconst E_BAD_AUTOLOADED_INITIALIZER = 'E_BAD_AUTOLOADED_INITIALIZER';\nconst E_BAD_AUTOLOADER = 'E_BAD_AUTOLOADER';\nconst E_AUTOLOADED_INITIALIZER_MISMATCH = 'E_AUTOLOADED_INITIALIZER_MISMATCH';\nconst E_UNMATCHED_DEPENDENCY = 'E_UNMATCHED_DEPENDENCY';\nconst E_CIRCULAR_DEPENDENCY = 'E_CIRCULAR_DEPENDENCY';\nconst E_BAD_INITIALIZER = 'E_BAD_INITIALIZER';\nconst E_ANONYMOUS_ANALYZER = 'E_ANONYMOUS_ANALYZER';\nconst E_BAD_SERVICE_PROVIDER = 'E_BAD_SERVICE_PROVIDER';\nconst E_BAD_SERVICE_PROMISE = 'E_BAD_SERVICE_PROMISE';\nconst E_INSTANCE_DESTROYED = 'E_INSTANCE_DESTROYED';\nconst E_AUTOLOADER_DYNAMIC_DEPENDENCY = 'E_AUTOLOADER_DYNAMIC_DEPENDENCY';\nconst E_BAD_CLASS = 'E_BAD_CLASS';\nconst E_UNDEFINED_CONSTANT_INITIALIZER = 'E_UNDEFINED_CONSTANT_INITIALIZER';\nconst E_BAD_VALUED_NON_CONSTANT_INITIALIZER =\n  'E_BAD_VALUED_NON_CONSTANT_INITIALIZER';\n\n/* Architecture Note #1: Knifecycle\n\nThe `knifecycle` project is intended to be a [dependency\n injection](https://en.wikipedia.org/wiki/Dependency_injection)\n with [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control)\n tool. It will always be tied to this goal since I prefer\n composing software instead of using frameworks and DI/IC is\n a major part to design strong software in my opinion.\n\nIt is designed to have a low footprint on services code.\n There is nothing worse than having to write specific code for\n a given tool. With `knifecycle`, services can be either constants,\n functions or objects created synchronously or asynchronously. They\n can be reused elsewhere (even when not using DI) with no changes\n at all since they are just simple functions with annotations\n set as a property.\n*/\n\n/* Architecture Note #1.1: OOP\nThe `knifecycle` use case is one of the rare use case where\n [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming)\n principles are a good fit.\n\nA service provider is full of state since its concern is\n precisely to\n [encapsulate](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))\n your application global states.\n*/\nclass Knifecycle<\n  D extends Dependencies,\n  AD extends InternalDependencies<D> = InternalDependencies<D>,\n  AS extends Service = AD[string]\n> {\n  private _silosCounter: number;\n  private _silosContexts: Set<AD['$siloContext']>;\n  private _initializers: Map<string, ProviderInitializer<Dependencies<AS>, AS>>;\n  private _initializerResolvers: Map<\n    string,\n    Promise<ProviderInitializer<Dependencies<AS>, AS>>\n  >;\n  private _singletonsServicesHandles: Map<string, Set<string>>;\n  private _singletonsServicesDescriptors: Map<\n    string,\n    {\n      promise: Promise<Provider<AS>>;\n      preloaded: boolean;\n    }\n  >;\n  private _singletonsServicesShutdownsPromises: Map<string, Promise<void>>;\n  private shutdownPromise: Promise<void>;\n\n  /**\n   * Create a new Knifecycle instance\n   * @return {Knifecycle}\n   * The Knifecycle instance\n   * @example\n   *\n   * import Knifecycle from 'knifecycle'\n   *\n   * const $ = new Knifecycle();\n   */\n  constructor() {\n    this._silosCounter = 0;\n    this._silosContexts = new Set();\n    this._initializers = new Map();\n    this._initializerResolvers = new Map();\n    this._singletonsServicesHandles = new Map();\n    this._singletonsServicesDescriptors = new Map();\n    this._singletonsServicesShutdownsPromises = new Map();\n    this.register(constant(INSTANCE, this as AS));\n\n    const initInjectorProvider = initializer(\n      {\n        name: INJECTOR,\n        type: 'provider',\n        inject: [SILO_CONTEXT],\n        // Despite its global definition, the injector\n        // depends on the silo context and then needs\n        // to be instanciated once per silo.\n        singleton: false,\n      },\n      async ({ $siloContext }: AD): Promise<Provider<AS>> => ({\n        service: (async (dependenciesDeclarations: DependencyDeclaration[]) =>\n          _buildFinalHash(\n            await this._initializeDependencies(\n              $siloContext,\n              $siloContext.name,\n              dependenciesDeclarations,\n              { injectorContext: true, autoloading: false },\n            ),\n            dependenciesDeclarations,\n          )) as AS,\n      }),\n    );\n\n    this.register(initInjectorProvider);\n  }\n\n  /* Architecture Note #1.3: Registering initializers\n\n  The first step to use `knifecycle` is to create a new\n   `Knifecycle` instance and register the previously\n   created initializers.\n\n  Initializers can be of three types:\n  - constants: a `constant` initializer resolves to\n   a constant value.\n  - services: a `service` initializer directly\n   resolve to the actual service it builds. It can\n   be objects, functions or litteral values.\n  - providers: they instead resolve to an object that\n   contains the service built into the `service` property\n   but also an optional `dispose` property exposing a\n   method to properly stop the service and a\n   `fatalErrorPromise` that will be rejected if an\n   unrecoverable error happens.\n\n   Initializers can be declared as singletons. This means\n    that they will be instanciated once for all for each\n    executions silos using them (we will cover this\n    topic later on).\n  */\n\n  /**\n   * Register an initializer\n   * @param  {Function}   initializer\n   * An initializer\n   * @return {Knifecycle}\n   * The Knifecycle instance (for chaining)\n   */\n  register(\n    initializer: Initializer<AS, Dependencies<AS>>,\n  ): Knifecycle<D, AD, AS> {\n    if (this.shutdownPromise) {\n      throw new YError(E_INSTANCE_DESTROYED);\n    }\n\n    unwrapInitializerProperties(initializer);\n\n    // Temporary cast constants into providers\n    // Best would be to threat each differently\n    // at dependencies initialization level to boost performances\n    if (initializer[SPECIAL_PROPS.TYPE] === 'constant') {\n      const value = initializer[SPECIAL_PROPS.VALUE];\n\n      if ('undefined' === typeof value) {\n        throw new YError(\n          E_UNDEFINED_CONSTANT_INITIALIZER,\n          initializer[SPECIAL_PROPS.NAME],\n        );\n      }\n\n      initializer = provider(\n        async () => ({\n          service: value,\n        }),\n        initializer[SPECIAL_PROPS.NAME],\n        [],\n        true,\n      );\n\n      // Needed for the build utils to still recognize\n      // this initializer as a constant value\n      initializer[SPECIAL_PROPS.VALUE] = value;\n      initializer[SPECIAL_PROPS.TYPE] = 'constant';\n    } else if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {\n      throw new YError(\n        E_BAD_VALUED_NON_CONSTANT_INITIALIZER,\n        initializer[SPECIAL_PROPS.NAME],\n      );\n    }\n\n    // Temporary cast service initializers into\n    // providers. Best would be to threat each differently\n    // at dependencies initialization level to boost performances\n    if ('service' === initializer[SPECIAL_PROPS.TYPE]) {\n      initializer = reuseSpecialProps(\n        initializer as ServiceInitializer<Dependencies<AS>, AS>,\n        serviceAdapter.bind(null, initializer[SPECIAL_PROPS.NAME], initializer),\n      ) as Initializer<AS, Dependencies<AS>>;\n      initializer[SPECIAL_PROPS.TYPE] = 'provider';\n    }\n\n    const initializerDependsOfItself = initializer[SPECIAL_PROPS.INJECT]\n      .map(_pickServiceNameFromDeclaration)\n      .includes(initializer[SPECIAL_PROPS.NAME]);\n\n    if (initializerDependsOfItself) {\n      throw new YError(E_CIRCULAR_DEPENDENCY, initializer[SPECIAL_PROPS.NAME]);\n    }\n\n    initializer[SPECIAL_PROPS.INJECT].forEach((dependencyDeclaration) => {\n      this._lookupCircularDependencies(\n        initializer[SPECIAL_PROPS.NAME],\n        dependencyDeclaration,\n      );\n    });\n\n    if (this._initializers.has(initializer[SPECIAL_PROPS.NAME])) {\n      const initializedAsSingleton =\n        this._singletonsServicesHandles.has(initializer[SPECIAL_PROPS.NAME]) &&\n        this._singletonsServicesDescriptors.has(\n          initializer[SPECIAL_PROPS.NAME],\n        ) &&\n        !this._singletonsServicesDescriptors.get(\n          initializer[SPECIAL_PROPS.NAME],\n        ).preloaded;\n      const initializedAsInstance = [\n        ...this._silosContexts.values(),\n      ].some((siloContext) =>\n        siloContext.servicesSequence.some((sequence) =>\n          sequence.includes(initializer[SPECIAL_PROPS.NAME]),\n        ),\n      );\n      if (initializedAsSingleton || initializedAsInstance) {\n        throw new YError(\n          'E_INITIALIZER_ALREADY_INSTANCIATED',\n          initializer[SPECIAL_PROPS.NAME],\n        );\n      }\n      debug(`'Overridden an initializer: ${initializer[SPECIAL_PROPS.NAME]}`);\n    } else {\n      debug(`Registered an initializer: ${initializer[SPECIAL_PROPS.NAME]}`);\n    }\n\n    // Constants are singletons and constant so we can set it\n    // to singleton services descriptors map directly\n    if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {\n      const handlesSet = new Set<string>();\n\n      this._singletonsServicesHandles.set(\n        initializer[SPECIAL_PROPS.NAME],\n        handlesSet,\n      );\n      this._singletonsServicesDescriptors.set(initializer[SPECIAL_PROPS.NAME], {\n        preloaded: true,\n        // We do not directly use initializer[SPECIAL_PROPS.VALUE] here\n        // since it looks like there is a bug with Babel build that\n        // change functions to empty litteral objects\n        promise: (initializer as ProviderInitializer<Dependencies<AS>, AS>)(),\n      });\n    }\n\n    this._initializers.set(\n      initializer[SPECIAL_PROPS.NAME],\n      initializer as ProviderInitializer<Dependencies<AS>, AS>,\n    );\n    return this;\n  }\n\n  _lookupCircularDependencies(\n    rootServiceName: ServiceName,\n    dependencyDeclaration: DependencyDeclaration,\n    declarationsStacks: DependencyDeclaration[] = [],\n  ): void {\n    const serviceName = _pickServiceNameFromDeclaration(dependencyDeclaration);\n    const dependencyProvider = this._initializers.get(serviceName);\n\n    if (!dependencyProvider) {\n      return;\n    }\n    declarationsStacks = declarationsStacks.concat(dependencyDeclaration);\n    dependencyProvider[SPECIAL_PROPS.INJECT].forEach(\n      (childDependencyDeclaration) => {\n        const childServiceName = _pickServiceNameFromDeclaration(\n          childDependencyDeclaration,\n        );\n\n        if (rootServiceName === childServiceName) {\n          throw new YError(\n            E_CIRCULAR_DEPENDENCY,\n            ...[rootServiceName]\n              .concat(declarationsStacks)\n              .concat(childDependencyDeclaration),\n          );\n        }\n\n        this._lookupCircularDependencies(\n          rootServiceName,\n          childDependencyDeclaration,\n          declarationsStacks,\n        );\n      },\n    );\n  }\n\n  /**\n   * Outputs a Mermaid compatible dependency graph of the declared services.\n   * See [Mermaid docs](https://github.com/knsv/mermaid)\n   * @param {Object} options\n   * Options for generating the graph (destructured)\n   * @param {Array<Object>} options.shapes\n   * Various shapes to apply\n   * @param {Array<Object>} options.styles\n   * Various styles to apply\n   * @param {Object} options.classes\n   * A hash of various classes contents\n   * @return {String}\n   * Returns a string containing the Mermaid dependency graph\n   * @example\n   *\n   * import Knifecycle, { inject, constant, service } from 'knifecycle';\n   * import appInitializer from './app';\n   *\n   * const $ = new Knifecycle();\n   *\n   * $.register(constant('ENV', process.env));\n   * $.register(constant('OS', require('os')));\n   * $.register(service('app', inject(['ENV', 'OS'], appInitializer)));\n   * $.toMermaidGraph();\n   *\n   * // returns\n   * graph TD\n   *   app-->ENV\n   *   app-->OS\n   */\n\n  toMermaidGraph(\n    {\n      shapes = [],\n      styles = [],\n      classes = {},\n    }: {\n      shapes: {\n        pattern: RegExp;\n        template: string;\n      }[];\n      styles: {\n        pattern: RegExp;\n        className: string;\n      }[];\n      classes: {\n        [name: string]: string;\n      };\n    } = {\n      shapes: [],\n      styles: [],\n      classes: {},\n    },\n  ): string {\n    const servicesProviders = this._initializers;\n    const links = Array.from(servicesProviders.keys())\n      .filter((provider) => !provider.startsWith('$'))\n      .reduce((links, serviceName) => {\n        const serviceProvider = servicesProviders.get(serviceName);\n\n        if (!serviceProvider[SPECIAL_PROPS.INJECT].length) {\n          return links;\n        }\n        return links.concat(\n          serviceProvider[SPECIAL_PROPS.INJECT].map((dependencyDeclaration) => {\n            const dependedServiceName = _pickServiceNameFromDeclaration(\n              dependencyDeclaration,\n            );\n\n            return { serviceName, dependedServiceName };\n          }),\n        );\n      }, []);\n    const classesApplications = _applyClasses(classes, styles, links);\n\n    if (!links.length) {\n      return '';\n    }\n\n    return ['graph TD']\n      .concat(\n        links.map(\n          ({ serviceName, dependedServiceName }) =>\n            `  ${_applyShapes(shapes, serviceName) || serviceName}-->${\n              _applyShapes(shapes, dependedServiceName) || dependedServiceName\n            }`,\n        ),\n      )\n      .concat(\n        Object.keys(classes).map(\n          (className) => `  classDef ${className} ${classes[className]}`,\n        ),\n      )\n      .concat(\n        Object.keys(classesApplications).map(\n          (serviceName) =>\n            `  class ${serviceName} ${classesApplications[serviceName]};`,\n        ),\n      )\n      .join('\\n');\n  }\n\n  /* Architecture Note #1.4: Execution silos\n  Once every initializers are registered, we need a way to bring\n   them to life. Execution silos are where the magic happens.\n   For each call of the `run` method with given dependencies,\n   a new silo is created and the required environment to\n   run the actual code is leveraged.\n\n  Depending on your application design, you could run it\n   in only one execution silo or into several ones\n   according to the isolation level your wish to reach.\n  */\n\n  /**\n   * Creates a new execution silo\n   * @param  {String[]}   dependenciesDeclarations\n   * Service name.\n   * @return {Promise}\n   * Service descriptor promise\n   * @example\n   *\n   * import Knifecycle, { constant } from 'knifecycle'\n   *\n   * const $ = new Knifecycle();\n   *\n   * $.register(constant('ENV', process.env));\n   * $.run(['ENV'])\n   * .then(({ ENV }) => {\n   *  // Here goes your code\n   * })\n   */\n  async run<ID extends Partial<AD> = AD>(\n    dependenciesDeclarations: DependencyDeclaration[],\n  ): Promise<ID> {\n    const _this = this;\n    const internalDependencies = [\n      ...new Set(dependenciesDeclarations.concat(DISPOSE)),\n    ];\n    const siloContext: SiloContext<AS> = {\n      name: `silo-${this._silosCounter++}`,\n      servicesDescriptors: new Map(),\n      servicesSequence: [],\n      servicesShutdownsPromises: new Map(),\n      errorsPromises: [],\n    };\n\n    if (this.shutdownPromise) {\n      throw new YError(E_INSTANCE_DESTROYED);\n    }\n\n    // Create a provider for the special fatal error service\n    siloContext.servicesDescriptors.set(\n      FATAL_ERROR,\n      Promise.resolve({\n        service: {\n          promise: new Promise<void>((resolve, reject) => {\n            siloContext.throwFatalError = (err) => {\n              debug('Handled a fatal error', err);\n              reject(err);\n            };\n          }),\n        } as AS,\n      }),\n    );\n\n    // Make the siloContext available for internal injections\n    siloContext.servicesDescriptors.set(\n      SILO_CONTEXT,\n      Promise.resolve({\n        service: siloContext as AS,\n      }),\n    );\n    // Create a provider for the shutdown special dependency\n    siloContext.servicesDescriptors.set(\n      DISPOSE,\n      Promise.resolve({\n        service: (async () => {\n          siloContext.shutdownPromise =\n            siloContext.shutdownPromise ||\n            _shutdownNextServices(siloContext.servicesSequence);\n\n          debug('Shutting down services');\n\n          await siloContext.shutdownPromise;\n\n          this._silosContexts.delete(siloContext as AD['$siloContext']);\n\n          // Shutdown services in their instanciation order\n          async function _shutdownNextServices(reversedServiceSequence) {\n            if (0 === reversedServiceSequence.length) {\n              return;\n            }\n\n            await Promise.all(\n              reversedServiceSequence.pop().map(async (serviceName) => {\n                const singletonServiceDescriptor = await _this._pickupSingletonServiceDescriptorPromise(\n                  serviceName,\n                );\n                const serviceDescriptor =\n                  singletonServiceDescriptor ||\n                  (await siloContext.servicesDescriptors.get(serviceName));\n                let serviceShutdownPromise: Promise<void> =\n                  _this._singletonsServicesShutdownsPromises.get(serviceName) ||\n                  siloContext.servicesShutdownsPromises.get(serviceName);\n\n                if (serviceShutdownPromise) {\n                  debug('Reusing a service shutdown promise:', serviceName);\n                  return serviceShutdownPromise;\n                }\n\n                if (\n                  reversedServiceSequence.some((servicesDeclarations) =>\n                    servicesDeclarations.includes(serviceName),\n                  )\n                ) {\n                  debug('Delaying service shutdown:', serviceName);\n                  return Promise.resolve();\n                }\n                if (singletonServiceDescriptor) {\n                  const handleSet = _this._singletonsServicesHandles.get(\n                    serviceName,\n                  );\n\n                  handleSet.delete(siloContext.name);\n                  if (handleSet.size) {\n                    debug(\n                      'Singleton is used elsewhere:',\n                      serviceName,\n                      handleSet,\n                    );\n                    return Promise.resolve();\n                  }\n                  _this._singletonsServicesDescriptors.delete(serviceName);\n                }\n                debug('Shutting down a service:', serviceName);\n                serviceShutdownPromise = serviceDescriptor.dispose\n                  ? serviceDescriptor.dispose()\n                  : Promise.resolve();\n                if (singletonServiceDescriptor) {\n                  _this._singletonsServicesShutdownsPromises.set(\n                    serviceName,\n                    serviceShutdownPromise,\n                  );\n                }\n                siloContext.servicesShutdownsPromises.set(\n                  serviceName,\n                  serviceShutdownPromise,\n                );\n                return serviceShutdownPromise;\n              }),\n            );\n\n            await _shutdownNextServices(reversedServiceSequence);\n          }\n        }) as AS,\n        dispose: Promise.resolve.bind(Promise),\n      }),\n    );\n\n    this._silosContexts.add(siloContext as AD['$siloContext']);\n\n    const servicesHash = await this._initializeDependencies(\n      siloContext,\n      siloContext.name,\n      internalDependencies,\n      { injectorContext: false, autoloading: false },\n    );\n\n    debug('Handling fatal errors:', siloContext.errorsPromises);\n    Promise.all(siloContext.errorsPromises).catch(siloContext.throwFatalError);\n\n    return _buildFinalHash(servicesHash, dependenciesDeclarations);\n  }\n\n  /**\n   * Destroy the Knifecycle instance\n   * @return {Promise}\n   * Full destruction promise\n   * @example\n   *\n   * import Knifecycle, { constant } from 'knifecycle'\n   *\n   * const $ = new Knifecycle();\n   *\n   * $.register(constant('ENV', process.env));\n   * $.run(['ENV'])\n   * .then(({ ENV }) => {\n   *    // Here goes your code\n   *\n   *    // Finally destroy the instance\n   *    $.destroy()\n   * })\n   */\n  async destroy(): Promise<void> {\n    this.shutdownPromise =\n      this.shutdownPromise ||\n      Promise.all(\n        [...this._silosContexts].map(async (siloContext) => {\n          const $dispose = (await siloContext.servicesDescriptors.get(DISPOSE))\n            .service as Disposer;\n\n          return $dispose();\n        }),\n      ).then(() => undefined);\n\n    debug('Shutting down Knifecycle instance.');\n\n    return this.shutdownPromise;\n  }\n\n  /**\n   * Initialize or return a service descriptor\n   * @param  {Object}     siloContext\n   * Current execution silo context\n   * @param  {String}     serviceName\n   * Service name.\n   * @param  {Object}     options\n   * Options for service retrieval\n   * @param  {Boolean}    options.injectorContext\n   * Flag indicating the injection were initiated by the $injector\n   * @param  {Boolean}    options.autoloading\n   * Flag to indicating $autoload dependencies on the fly loading\n   * @param  {String}     serviceProvider\n   * Service provider.\n   * @return {Promise}\n   * Service descriptor promise.\n   */\n  async _getServiceDescriptor(\n    siloContext: SiloContext<AS>,\n    serviceName: ServiceName,\n    {\n      injectorContext,\n      autoloading,\n    }: { injectorContext: boolean; autoloading: boolean },\n  ): Promise<Provider<AS>> {\n    // Try to get service descriptior early from the silo context\n    let serviceDescriptorPromise = siloContext.servicesDescriptors.get(\n      serviceName,\n    );\n    if (serviceDescriptorPromise) {\n      if (autoloading) {\n        debug(\n          `⚠️ - Possible dead lock due to reusing \"${serviceName}\" from the silo context while autoloading.`,\n        );\n      }\n      return serviceDescriptorPromise;\n    }\n\n    const initializer = await this._findInitializer(siloContext, serviceName, {\n      injectorContext,\n      autoloading,\n    });\n\n    serviceDescriptorPromise = this._pickupSingletonServiceDescriptorPromise(\n      serviceName,\n    );\n\n    if (serviceDescriptorPromise) {\n      if (autoloading) {\n        debug(\n          `⚠️ - Possible dead lock due to reusing the singleton \"${serviceName}\" while autoloading.`,\n        );\n      }\n      this._singletonsServicesHandles.get(serviceName).add(siloContext.name);\n    } else {\n      serviceDescriptorPromise = siloContext.servicesDescriptors.get(\n        serviceName,\n      );\n    }\n\n    if (serviceDescriptorPromise) {\n      return serviceDescriptorPromise;\n    }\n\n    // The $injector service is mainly intended to be used as a workaround\n    // for unavoidable circular dependencies. It rarely make sense to\n    // instanciate new services at this level so printing a warning for\n    // debug purposes\n    if (injectorContext) {\n      debug(\n        'Warning: Instantiating a new service via the $injector. It may' +\n          ' mean that you no longer need it if your worked around a circular' +\n          ' dependency.',\n      );\n    }\n\n    serviceDescriptorPromise = this._initializeServiceDescriptor(\n      siloContext,\n      serviceName,\n      initializer,\n      {\n        autoloading: autoloading || AUTOLOAD === serviceName,\n        injectorContext,\n      },\n    );\n\n    if (initializer[SPECIAL_PROPS.SINGLETON]) {\n      const handlesSet = new Set<string>();\n\n      handlesSet.add(siloContext.name);\n      this._singletonsServicesHandles.set(serviceName, handlesSet);\n      this._singletonsServicesDescriptors.set(serviceName, {\n        preloaded: false,\n        promise: serviceDescriptorPromise,\n      });\n    } else {\n      siloContext.servicesDescriptors.set(\n        serviceName,\n        serviceDescriptorPromise,\n      );\n    }\n    // Since the autoloader is a bit special it must be pushed here\n    if (AUTOLOAD === serviceName) {\n      siloContext.servicesSequence.unshift([AUTOLOAD]);\n    }\n    return serviceDescriptorPromise;\n  }\n\n  async _findInitializer(\n    siloContext: SiloContext<AS>,\n    serviceName: ServiceName,\n    {\n      injectorContext,\n      autoloading,\n    }: { injectorContext: boolean; autoloading: boolean },\n  ): Promise<ProviderInitializer<Dependencies<AS>, AS>> {\n    const initializer = this._initializers.get(serviceName);\n\n    if (initializer) {\n      return initializer;\n    }\n\n    // The auto loader must only have static dependencies\n    // and we have to do this check here to avoid caching\n    // non-autoloading request and then be blocked by an\n    // autoloader dep that waits for that cached load\n    if (autoloading) {\n      throw new YError(E_AUTOLOADER_DYNAMIC_DEPENDENCY, serviceName);\n    }\n\n    debug('No service provider:', serviceName);\n\n    let initializerPromise = this._initializerResolvers.get(serviceName);\n\n    if (initializerPromise) {\n      return await initializerPromise;\n    }\n\n    initializerPromise = (async () => {\n      if (!this._initializers.get(AUTOLOAD)) {\n        throw new YError(E_UNMATCHED_DEPENDENCY, serviceName);\n      }\n      debug(`Loading the $autoload service to lookup for: ${serviceName}.`);\n      try {\n        const autoloadingDescriptor = (await this._getServiceDescriptor(\n          siloContext,\n          AUTOLOAD,\n          { injectorContext, autoloading: true },\n        )) as Provider<Autoloader<AS>>;\n        const { initializer, path } = await autoloadingDescriptor.service(\n          serviceName,\n        );\n\n        if (\n          typeof initializer !== 'function' &&\n          (typeof initializer !== 'object' ||\n            initializer[SPECIAL_PROPS.TYPE] !== 'constant')\n        ) {\n          throw new YError(\n            E_BAD_AUTOLOADED_INITIALIZER,\n            serviceName,\n            initializer,\n          );\n        }\n\n        if (initializer[SPECIAL_PROPS.NAME] !== serviceName) {\n          throw new YError(\n            E_AUTOLOADED_INITIALIZER_MISMATCH,\n            serviceName,\n            initializer[SPECIAL_PROPS.NAME],\n          );\n        }\n\n        debug(`Loaded the ${serviceName} initializer at path ${path}.`);\n        this.register(initializer);\n        this._initializerResolvers.delete(serviceName);\n        // Here we need to pick-up the registered initializer to\n        // have a universally usable intitializer\n        return this._initializers.get(serviceName);\n      } catch (err) {\n        debug(`Could not load ${serviceName} via the auto loader.`);\n        throw err;\n      }\n    })();\n\n    this._initializerResolvers.set(serviceName, initializerPromise);\n\n    return await initializerPromise;\n  }\n\n  _pickupSingletonServiceDescriptorPromise(\n    serviceName: ServiceName,\n  ): Promise<Provider<AS>> {\n    const serviceDescriptor = this._singletonsServicesDescriptors.get(\n      serviceName,\n    );\n\n    if (!serviceDescriptor) {\n      return;\n    }\n\n    serviceDescriptor.preloaded = false;\n\n    return serviceDescriptor.promise;\n  }\n\n  /**\n   * Initialize a service descriptor\n   * @param  {Object}     siloContext\n   * Current execution silo context\n   * @param  {String}     serviceName\n   * Service name.\n   * @param  {Object}     options\n   * Options for service retrieval\n   * @param  {Boolean}    options.injectorContext\n   * Flag indicating the injection were initiated by the $injector\n   * @param  {Boolean}    options.autoloading\n   * Flag to indicating $autoload dependendencies on the fly loading.\n   * @return {Promise}\n   * Service dependencies hash promise.\n   */\n  async _initializeServiceDescriptor(\n    siloContext: SiloContext<AS>,\n    serviceName: ServiceName,\n    initializer: ProviderInitializer<Dependencies<AS>, AS>,\n    {\n      autoloading,\n      injectorContext,\n    }: { autoloading: boolean; injectorContext: boolean },\n  ): Promise<Provider<AS>> {\n    let serviceDescriptor: Provider<AS>;\n\n    debug('Initializing a service descriptor:', serviceName);\n\n    try {\n      // A singleton service may use a reserved resource\n      // like a TCP socket. This is why we have to be aware\n      // of singleton services full shutdown before creating\n      // a new one\n\n      await (this._singletonsServicesShutdownsPromises.get(serviceName) ||\n        Promise.resolve());\n      // Anyway delete any shutdown promise before instanciating\n      // a new service\n      this._singletonsServicesShutdownsPromises.delete(serviceName);\n      siloContext.servicesShutdownsPromises.delete(serviceName);\n\n      const servicesHash = await this._initializeDependencies(\n        siloContext,\n        serviceName,\n        initializer[SPECIAL_PROPS.INJECT],\n        { injectorContext, autoloading },\n      );\n\n      debug('Successfully gathered service dependencies:', serviceName);\n\n      serviceDescriptor = await initializer(\n        initializer[SPECIAL_PROPS.INJECT].reduce(\n          (finalHash, dependencyDeclaration) => {\n            const { serviceName, mappedName } = parseDependencyDeclaration(\n              dependencyDeclaration,\n            );\n\n            finalHash[serviceName] = servicesHash[mappedName];\n            return finalHash;\n          },\n          {},\n        ),\n      );\n\n      if (!serviceDescriptor) {\n        debug('Provider did not return a descriptor:', serviceName);\n        return Promise.reject(new YError(E_BAD_SERVICE_PROVIDER, serviceName));\n      }\n      debug('Successfully initialized a service descriptor:', serviceName);\n      if (serviceDescriptor.fatalErrorPromise) {\n        debug('Registering service descriptor error promise:', serviceName);\n        siloContext.errorsPromises.push(serviceDescriptor.fatalErrorPromise);\n      }\n      siloContext.servicesDescriptors.set(\n        serviceName,\n        Promise.resolve(serviceDescriptor),\n      );\n    } catch (err) {\n      debug('Error initializing a service descriptor:', serviceName, err.stack);\n      if (E_UNMATCHED_DEPENDENCY === err.code) {\n        throw YError.wrap(\n          err,\n          E_UNMATCHED_DEPENDENCY,\n          ...[serviceName].concat(err.params),\n        );\n      }\n      throw err;\n    }\n    return serviceDescriptor;\n  }\n\n  /**\n   * Initialize a service dependencies\n   * @param  {Object}     siloContext\n   * Current execution silo siloContext\n   * @param  {String}     serviceName\n   * Service name.\n   * @param  {String}     servicesDeclarations\n   * Dependencies declarations.\n   * @param  {Object}     options\n   * Options for service retrieval\n   * @param  {Boolean}    options.injectorContext\n   * Flag indicating the injection were initiated by the $injector\n   * @param  {Boolean}    options.autoloading\n   * Flag to indicating $autoload dependendencies on the fly loading.\n   * @return {Promise}\n   * Service dependencies hash promise.\n   */\n  async _initializeDependencies(\n    siloContext: SiloContext<AS>,\n    serviceName: ServiceName,\n    servicesDeclarations: DependencyDeclaration[],\n    {\n      injectorContext = false,\n      autoloading = false,\n    }: { autoloading: boolean; injectorContext: boolean },\n  ): Promise<Dependencies> {\n    debug('Initializing dependencies:', serviceName, servicesDeclarations);\n    const servicesDescriptors: Provider<AS>[] = await Promise.all(\n      servicesDeclarations.map(async (serviceDeclaration) => {\n        const { mappedName, optional } = parseDependencyDeclaration(\n          serviceDeclaration,\n        );\n\n        try {\n          const serviceDescriptor = await this._getServiceDescriptor(\n            siloContext,\n            mappedName,\n            {\n              injectorContext,\n              autoloading,\n            },\n          );\n          return serviceDescriptor;\n        } catch (err) {\n          if (\n            optional &&\n            [\n              'E_UNMATCHED_DEPENDENCY',\n              E_AUTOLOADER_DYNAMIC_DEPENDENCY,\n            ].includes(err.code)\n          ) {\n            debug(\n              'Optional dependency not found:',\n              serviceDeclaration,\n              err.stack,\n            );\n            return;\n          }\n          throw err;\n        }\n      }),\n    );\n    debug(\n      'Initialized dependencies descriptors:',\n      serviceName,\n      servicesDeclarations,\n      servicesDescriptors,\n    );\n    siloContext.servicesSequence.push(\n      servicesDeclarations\n        .filter((_, index) => servicesDescriptors[index])\n        .map(_pickMappedNameFromDeclaration),\n    );\n\n    const services = await Promise.all(\n      servicesDescriptors.map(async (serviceDescriptor) => {\n        if (!serviceDescriptor) {\n          return undefined;\n        }\n        return serviceDescriptor.service;\n      }),\n    );\n\n    return services.reduce((hash, service, index) => {\n      const mappedName = _pickMappedNameFromDeclaration(\n        servicesDeclarations[index],\n      );\n\n      hash[mappedName] = service;\n      return hash;\n    }, {});\n  }\n}\n\nexport default Knifecycle;\nexport {\n  SPECIAL_PROPS,\n  SPECIAL_PROPS_PREFIX,\n  DECLARATION_SEPARATOR,\n  OPTIONAL_FLAG,\n  ALLOWED_INITIALIZER_TYPES,\n  ALLOWED_SPECIAL_PROPS,\n  parseInjections,\n  readFunctionName,\n  parseName,\n  Knifecycle,\n  initializer,\n  name,\n  autoName,\n  type,\n  inject,\n  useInject,\n  mergeInject,\n  autoInject,\n  alsoInject,\n  extra,\n  singleton,\n  reuseSpecialProps,\n  wrapInitializer,\n  constant,\n  service,\n  autoService,\n  provider,\n  autoProvider,\n  handler,\n  autoHandler,\n  parseDependencyDeclaration,\n  stringifyDependencyDeclaration,\n  unwrapInitializerProperties,\n  initInitializerBuilder,\n};\n\nfunction _pickServiceNameFromDeclaration(dependencyDeclaration) {\n  const { serviceName } = parseDependencyDeclaration(dependencyDeclaration);\n\n  return serviceName;\n}\n\nfunction _pickMappedNameFromDeclaration(dependencyDeclaration) {\n  const { mappedName } = parseDependencyDeclaration(dependencyDeclaration);\n\n  return mappedName;\n}\n\nfunction _applyShapes(shapes, serviceName) {\n  return shapes.reduce((shapedService, shape) => {\n    if (shapedService) {\n      return shapedService;\n    }\n\n    const matches = shape.pattern.exec(serviceName);\n\n    if (!matches) {\n      return shapedService;\n    }\n    return shape.template.replace(\n      /\\$([0-9])+/g,\n      ($, $1) => matches[parseInt($1, 10)],\n    );\n  }, '');\n}\n\nfunction _applyClasses(classes, styles, links) {\n  return links.reduce(\n    (classesApplications, link) =>\n      Object.assign(classesApplications, _applyStyles(classes, styles, link)),\n    {},\n  );\n}\n\nfunction _applyStyles(classes, styles, { serviceName, dependedServiceName }) {\n  return styles.reduce((classesApplications, style) => {\n    if (style.pattern.test(serviceName) && !classesApplications[serviceName]) {\n      if (!classes[style.className]) {\n        throw new YError(E_BAD_CLASS, style.className, serviceName);\n      }\n      classesApplications[serviceName] = style.className;\n    }\n    if (\n      style.pattern.test(dependedServiceName) &&\n      !classesApplications[dependedServiceName]\n    ) {\n      if (!classes[style.className]) {\n        throw new YError(E_BAD_CLASS, style.className, dependedServiceName);\n      }\n      classesApplications[dependedServiceName] = style.className;\n    }\n    return classesApplications;\n  }, {});\n}\n\nfunction serviceAdapter<D extends Dependencies, S>(\n  serviceName: ServiceName,\n  initializer: ServiceInitializer<D, S>,\n  dependenciesHash: D,\n): Promise<Provider<S>> {\n  const servicePromise = initializer(dependenciesHash);\n\n  if (!servicePromise || !servicePromise.then) {\n    throw new YError(E_BAD_SERVICE_PROMISE, serviceName);\n  }\n\n  return servicePromise.then((_service_) => ({\n    service: _service_,\n  }));\n}\n\nfunction _buildFinalHash(servicesHash, dependenciesDeclarations) {\n  return dependenciesDeclarations.reduce((finalHash, dependencyDeclaration) => {\n    const { serviceName, mappedName } = parseDependencyDeclaration(\n      dependencyDeclaration,\n    );\n\n    finalHash[serviceName] = servicesHash[mappedName];\n    return finalHash;\n  }, {});\n}\n"],"file":"index.mjs"}