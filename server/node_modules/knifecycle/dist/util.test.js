"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _sinon = _interopRequireDefault(require("sinon"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function aProviderInitializer(_services) {
  return {
    service: 'A_PROVIDER_SERVICE'
  };
}

async function aServiceInitializer(_services) {
  return 'A_PROVIDER_SERVICE';
}

describe('reuseSpecialProps', () => {
  it('should work', () => {
    // We can safely ignore coverage here since the
    // function are here just as placeholders

    /* istanbul ignore next */
    async function from() {
      return 'from';
    }
    /* istanbul ignore next */


    async function to() {
      return 'to';
    }

    from.$name = 'from';
    from.$type = 'service';
    from.$inject = ['ki', 'kooo', 'lol'];
    from.$singleton = false;
    from.$extra = {
      httpHandler: true
    };
    const newFn = (0, _util.reuseSpecialProps)(from, to);

    _assert.default.notEqual(newFn, to);

    _assert.default.equal(newFn.$name, from.$name);

    _assert.default.equal(newFn.$type, from.$type);

    _assert.default.notEqual(newFn.$inject, from.$inject);

    _assert.default.deepEqual(newFn.$inject, from.$inject);

    _assert.default.equal(newFn.$singleton, from.$singleton);

    _assert.default.notEqual(newFn.$extra, from.$extra);

    _assert.default.deepEqual(newFn.$extra, from.$extra);

    const newFn2 = (0, _util.reuseSpecialProps)(from, to, {
      $name: 'yolo'
    });

    _assert.default.notEqual(newFn2, to);

    _assert.default.equal(newFn2.$name, 'yolo');

    _assert.default.equal(newFn2.$type, from.$type);

    _assert.default.notEqual(newFn2.$inject, from.$inject);

    _assert.default.deepEqual(newFn2.$inject, from.$inject);

    _assert.default.equal(newFn2.$singleton, from.$singleton);

    _assert.default.notEqual(newFn.$extra, from.$extra);

    _assert.default.deepEqual(newFn.$extra, from.$extra);
  });
});
describe('wrapInitializer', () => {
  it('should work with a service initializer', async () => {
    async function baseServiceInitializer() {
      return () => 'test';
    }

    const log = _sinon.default.stub();

    const newInitializer = (0, _util.wrapInitializer)(async ({
      log
    }, service) => {
      log('Wrapping...');
      return () => service() + '-wrapped';
    }, (0, _util.service)(baseServiceInitializer, 'baseServiceInitializer', ['log', '?test'], false, {
      httpHandler: false
    }));
    const newService = await newInitializer({
      log
    });

    _assert.default.equal(newService(), 'test-wrapped');

    _assert.default.deepEqual(log.args, [['Wrapping...']]);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['log', '?test']);
  });
  it('should work with a provider initialzer', async () => {
    async function baseInitializer() {
      return {
        service: () => 'test'
      };
    }

    const log = _sinon.default.stub();

    const baseProviderInitializer = (0, _util.provider)(baseInitializer, 'baseInitializer', ['log', '?test'], false, {
      httpHandler: false
    });
    const newInitializer = (0, _util.wrapInitializer)(async ({
      log
    }, service) => {
      log('Wrapping...');
      return {
        service: () => service.service() + '-wrapped'
      };
    }, baseProviderInitializer);
    const newService = await newInitializer({
      log
    });

    _assert.default.equal(newService.service(), 'test-wrapped');

    _assert.default.deepEqual(log.args, [['Wrapping...']]);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['log', '?test']);
  });
});
describe('inject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const dependencies = ['ENV'];
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.provider)(aProviderInitializer, 'aProvider'));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer builder with dependencies', () => {
    const dependencies = ['ENV'];
    const newInitializer = (0, _util.inject)(dependencies, aProviderInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with dependencies', () => {
    const dependencies = ['ENV'];
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.service)(aServiceInitializer, 'aService'));

    _assert.default.notEqual(newInitializer, aServiceInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer builder with dependencies', () => {
    const dependencies = ['ENV'];
    const newInitializer = (0, _util.inject)(dependencies, aServiceInitializer);

    _assert.default.notEqual(newInitializer, aServiceInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with mapped dependencies', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const newInitializer = (0, _util.inject)(dependencies, aProviderInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should fail with a constant', () => {
    _assert.default.throws(() => {
      (0, _util.inject)(['test'], (0, _util.constant)('test', 'test'));
    }, /E_BAD_INJECT_IN_CONSTANT/);
  });
});
describe('useInject', () => {
  it('should set the right dependencies', () => {
    const fromDependencies = ['ENV', 'CORS'];
    const fromInitializer = (0, _util.inject)(fromDependencies, aProviderInitializer);
    const toDependencies = ['db', 'log'];
    const toInitializer = (0, _util.inject)(toDependencies, aProviderInitializer);
    const newInitializer = (0, _util.useInject)(fromInitializer, toInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], fromDependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], toDependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], [...fromDependencies]);
  });
});
describe('mergeInject', () => {
  it('should amend dependencies', () => {
    const fromDependencies = ['ENV', 'CORS'];
    const fromInitializer = (0, _util.inject)(fromDependencies, aProviderInitializer);
    const toDependencies = ['db', 'log'];
    const toInitializer = (0, _util.inject)(toDependencies, aProviderInitializer);
    const newInitializer = (0, _util.mergeInject)(fromInitializer, toInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], fromDependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], toDependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], [...toDependencies, ...fromDependencies]);
  });
});
describe('autoInject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const baseProvider = async ({
      ENV,
      mysql: db
    }) => async () => ({
      ENV,
      db
    });

    const dependencies = ['ENV', 'mysql'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with a function name', () => {
    async function baseProvider({
      ENV,
      mysql: db
    }) {
      async () => ({
        ENV,
        db
      });
    }

    const dependencies = ['ENV', 'mysql'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with optional dependencies', () => {
    const noop = () => undefined;

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }) => async () => ({
      ENV,
      log,
      aDebug
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with several arguments', () => {
    const noop = () => undefined;

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }) => async () => ({
      ENV,
      log,
      aDebug
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with complex arguments', () => {
    const noop = () => undefined;

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }) => async () => ({
      ENV,
      log,
      aDebug
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should fail with non async initializers', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(({
        foo: bar = {
          bar: 'foo'
        }
      }) => {
        return bar;
      });
    }, /E_NON_ASYNC_INITIALIZER/);
  });
  it('should fail with too complex injections', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(async ({
        foo: bar = {
          bar: 'foo'
        }
      }) => {
        return bar;
      });
    }, /E_AUTO_INJECTION_FAILURE/);
  });
  it('should fail with no injections', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(async () => undefined);
    }, /E_AUTO_INJECTION_FAILURE/);
  });
});
describe('alsoInject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], (0, _util.inject)(['TEST'], aProviderInitializer));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['TEST', 'ENV']);
  });
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], aProviderInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);
  });
  it('should dedupe dependencies', () => {
    const baseProvider = (0, _util.inject)(['?TEST'], aProviderInitializer);
    const newInitializer = (0, _util.alsoInject)(['ENV', '?NODE_ENV', '?TEST', 'TEST2', 'db>mysql'], (0, _util.alsoInject)(['ENV', 'NODE_ENV', '?TEST', '?TEST2', 'mysql'], baseProvider));

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['mysql', 'ENV', 'NODE_ENV', '?TEST', 'TEST2', 'db>mysql']);
  });
  it('should preserve single optional dependencies', () => {
    const baseProvider = (0, _util.inject)(['ENV', '?TEST'], aProviderInitializer);
    const newInitializer = (0, _util.alsoInject)(['ENV', '?TEST2'], (0, _util.alsoInject)(['ENV', '?TEST3'], baseProvider));

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['?TEST', '?TEST3', 'ENV', '?TEST2']);
  });
  it('should preserve mapped dependencies', () => {
    const baseProvider = (0, _util.inject)(['mysql', '?sftp'], aProviderInitializer);
    const newInitializer = (0, _util.alsoInject)(['db>mysql', '?ftp>sftp'], baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['mysql', '?sftp', 'db>mysql', '?ftp>sftp']);
  });
  it('should solve dependencies alias name clash', () => {
    const baseProvider = (0, _util.inject)(['?TEST'], aProviderInitializer);
    const newInitializer = (0, _util.alsoInject)(['ENV', '?NODE_ENV', '?TEST', 'db>mysql', '?log>logly'], (0, _util.alsoInject)(['ENV', 'NODE_ENV', '?TEST', 'db>pg', '?log>logger'], baseProvider));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV', 'NODE_ENV', '?TEST', 'db>mysql', '?log>logly']);
  });
  it('should solve dependencies alias name clash', () => {
    const baseProvider = (0, _util.inject)(['?TEST'], aProviderInitializer);
    const newInitializer = (0, _util.alsoInject)(['ENV', '?NODE_ENV', '?TEST', 'db>mysql', '?log>logly'], (0, _util.alsoInject)(['ENV', 'NODE_ENV', '?TEST', 'db>pg', '?log>logger'], baseProvider));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV', 'NODE_ENV', '?TEST', 'db>mysql', '?log>logly']);
  });
});
describe('parseInjections', () => {
  it('should work with TypeScript dependencies', () => {
    _assert.default.deepEqual((0, _util.parseInjections)(`async function initNexmo({
      ENV,
      NEXMO,
      log = noop,
    }: {
      ENV: any;
      NEXMO: any;
      log: Function;
    }): Promise<SMSService> {}`), ['ENV', 'NEXMO', '?log']);
  });
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], aProviderInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);
  });
});
describe('singleton', () => {
  it('should allow to decorate an initializer with singleton option', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.singleton)(aProviderInitializer, true));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);
  });
  it('should allow to be used several times', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.singleton)((0, _util.singleton)(aProviderInitializer), false));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], false);
  });
});
describe('name', () => {
  it('should allow to decorate an initializer with a name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.name)(baseName, aProviderInitializer));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
});
describe('autoName', () => {
  it('should allow to decorate an initializer with its function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.autoName)(async function hash() {
      return undefined;
    }));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate an initializer with its init like function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.autoName)(async function initHash() {
      return undefined;
    }));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate an initializer with its initialize like function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.autoName)(async function initializeHash() {
      return undefined;
    }));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate a bounded initializer', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const newInitializer = (0, _util.autoName)((0, _util.inject)(dependencies, (0, _util.singleton)(async function initializeHash() {
      return undefined;
    })));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should fail with anonymous functions', () => {
    _assert.default.throws(() => {
      (0, _util.autoName)(async () => undefined);
    }, /E_AUTO_NAMING_FAILURE/);
  });
});
describe('extra', () => {
  it('should allow to decorate an initializer with extra infos', () => {
    const extraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(extraInformations, aProviderInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);
  });
  it('should allow to decorate an initializer with extra infos', () => {
    const extraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(extraInformations, aProviderInitializer, true);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);
  });
  it('should allow to decorate an initializer with additional extra infos', () => {
    const baseExtraInformations = {
      yolo: true,
      httpHandler: false
    };
    const additionalExtraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(baseExtraInformations, (0, _util.extra)(additionalExtraInformations, aProviderInitializer), true);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], baseExtraInformations);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], baseExtraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], { ...baseExtraInformations,
      ...baseExtraInformations
    });
  });
});
describe('type', () => {
  it('should allow to decorate an initializer with a type', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.name)(baseName, (0, _util.type)(baseType, aProviderInitializer)));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
});
describe('initializer', () => {
  it('should allow to decorate an initializer with every properties', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.initializer)({
      type: baseType,
      inject: dependencies,
      singleton: true,
      name: baseName
    }, aServiceInitializer);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with bad properties', () => {
    _assert.default.throws(() => {
      (0, _util.initializer)({
        name: 'yolo',
        yolo: ''
      }, async () => undefined);
    }, /E_BAD_PROPERTY/);
  });
});
describe('constant', () => {
  it('should allow to create an initializer from a constant', async () => {
    const baseName = 'THE_VALUE';
    const baseValue = 42;
    const constantInitializer = (0, _util.constant)(baseName, baseValue);

    _assert.default.equal(constantInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(constantInitializer[_util.SPECIAL_PROPS.TYPE], 'constant');

    _assert.default.equal(constantInitializer[_util.SPECIAL_PROPS.VALUE], baseValue);
  });
  it('should fail with dependencies since it makes no sense', () => {
    _assert.default.throws(() => {
      (0, _util.constant)('time', (0, _util.inject)(['hash3'], async () => undefined));
    }, /E_CONSTANT_INJECTION/);
  });
});
describe('service', () => {
  it('should allow to create an initializer from a service builder', async () => {
    const aServiceBuilder = async _services => 'A_SERVICE';

    const dependencies = ['ANOTHER_ENV>ENV'];
    const extraData = {
      cool: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.service)(aServiceBuilder, baseName, dependencies, true, extraData);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraData);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should allow to create an initializer from a generic service builder', async () => {
    const aServiceBuilder = async _services => '';

    const dependencies = ['ANOTHER_ENV>ENV'];
    const extraData = {
      nice: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.service)(aServiceBuilder, baseName, dependencies, true, extraData);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraData);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with no service builder', () => {
    _assert.default.throws(() => {
      (0, _util.service)(undefined);
    }, /E_NO_SERVICE_BUILDER/);
  });
});
describe('autoService', () => {
  it('should detect the service details', () => {
    const baseServiceBuilder = async function initializeMySQL({
      ENV
    }) {
      return ENV;
    };

    const newInitializer = (0, _util.autoService)(baseServiceBuilder);

    _assert.default.notEqual(newInitializer, baseServiceBuilder);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'service');
  });
  it('should detect the service details even with no dependencies', () => {
    const baseServiceBuilder = async function initializeMySQL() {
      return;
    };

    const newInitializer = (0, _util.autoService)(baseServiceBuilder);

    _assert.default.notEqual(newInitializer, baseServiceBuilder);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], []);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'service');
  });
});
describe('provider', () => {
  it('should allow to create an initializer from a provider builder', async () => {
    const aProviderInitializerBuilder = async () => ({
      service: 'A_SERVICE'
    });

    const dependencies = ['ANOTHER_ENV>ENV'];
    const extraData = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'provider';
    const newInitializer = (0, _util.provider)(aProviderInitializerBuilder, baseName, dependencies, true, extraData);

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraData);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should allow to create an initializer from a provider builder', async () => {
    const aServiceBuilder = async _services => ({
      service: 'A_SERVICE'
    });

    const dependencies = ['ANOTHER_ENV>ENV'];
    const extraData = {
      extra: true
    };
    const baseName = 'hash';
    const baseType = 'provider';
    const newInitializer = (0, _util.provider)((0, _util.name)(baseName, (0, _util.inject)(dependencies, (0, _util.singleton)((0, _util.extra)(extraData, aServiceBuilder)))));

    _assert.default.notEqual(newInitializer, aProviderInitializer);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.SINGLETON], true);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraData);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with no provider builder', () => {
    _assert.default.throws(() => {
      (0, _util.provider)(undefined);
    }, /E_NO_PROVIDER_BUILDER/);
  });
});
describe('autoProvider', () => {
  it('should detect the provider details', () => {
    const baseInitializer = async function initializeMySQL({
      ENV
    }) {
      return {
        service: ENV
      };
    };

    const newInitializer = (0, _util.autoProvider)(baseInitializer);

    _assert.default.notEqual(newInitializer, baseInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'provider');
  });
  it('should detect the provider details even with no dependencies', () => {
    const baseInitializer = async function initializeMySQL() {
      return {
        service: 'A_SERVICE'
      };
    };

    const newInitializer = (0, _util.autoProvider)(baseInitializer);

    _assert.default.notEqual(newInitializer, baseInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], []);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'provider');
  });
});
describe('handler', () => {
  it('should work', async () => {
    const baseName = 'sampleHandler';
    const injectedServices = ['kikooo', 'lol'];
    const services = {
      kikooo: 'kikooo',
      lol: 'lol'
    };
    const theInitializer = (0, _util.handler)(sampleHandler, baseName, injectedServices);

    _assert.default.deepEqual(theInitializer.$name, baseName);

    _assert.default.deepEqual(theInitializer.$inject, injectedServices);

    const theHandler = await theInitializer(services);
    const result = await theHandler('test');

    _assert.default.deepEqual(result, {
      deps: services,
      args: ['test']
    });

    async function sampleHandler(deps, ...args) {
      return {
        deps,
        args
      };
    }
  });
  it('should fail with no name', () => {
    _assert.default.throws(() => {
      (0, _util.handler)(() => undefined);
    }, /E_NO_HANDLER_NAME/);
  });
});
describe('autoHandler', () => {
  it('should work', async () => {
    const services = {
      kikooo: 'kikooo',
      lol: 'lol'
    };
    const theInitializer = (0, _util.autoHandler)(sampleHandler);

    _assert.default.deepEqual(theInitializer.$name, sampleHandler.name);

    _assert.default.deepEqual(theInitializer.$inject, ['kikooo', 'lol']);

    const theHandler = await theInitializer(services);
    const result = await theHandler('test');

    _assert.default.deepEqual(result, {
      deps: services,
      args: ['test']
    });

    async function sampleHandler({
      kikooo,
      lol
    }, ...args) {
      return {
        deps: {
          kikooo,
          lol
        },
        args
      };
    }
  });
  it('should work with spread services', async () => {
    const services = {
      kikooo: 'kikooo',
      lol: 'lol'
    };
    const theInitializer = (0, _util.autoHandler)(sampleHandler);

    _assert.default.deepEqual(theInitializer.$name, sampleHandler.name);

    _assert.default.deepEqual(theInitializer.$inject, ['kikooo', 'lol']);

    const theHandler = await theInitializer(services);
    const result = await theHandler('test');

    _assert.default.deepEqual(result, {
      deps: services,
      args: ['test']
    });

    async function sampleHandler({
      kikooo,
      lol,
      ...services
    }, ...args) {
      return {
        deps: {
          kikooo,
          lol,
          ...services
        },
        args
      };
    }
  });
  it('should fail for anonymous functions', () => {
    _assert.default.throws(() => {
      (0, _util.autoHandler)(() => undefined);
    }, /E_AUTO_NAMING_FAILURE/);
  });
});
describe('parseDependencyDeclaration', () => {
  it('should work', () => {
    _assert.default.deepEqual((0, _util.parseDependencyDeclaration)('db>pgsql'), {
      serviceName: 'db',
      mappedName: 'pgsql',
      optional: false
    });
  });
  it('should work with unmapped names', () => {
    _assert.default.deepEqual((0, _util.parseDependencyDeclaration)('?pgsql'), {
      serviceName: 'pgsql',
      mappedName: 'pgsql',
      optional: true
    });
  });
});
//# sourceMappingURL=util.test.js.map