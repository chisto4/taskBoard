function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, reuseSpecialProps, parseName, name, autoName, inject, useInject, mergeInject, autoInject, alsoInject, type, extra, singleton, initializer, constant, service, autoService, provider, autoProvider, wrapInitializer, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties } from './util';
import initInitializerBuilder from './build';
import YError from 'yerror';
import initDebug from 'debug';
const debug = initDebug('knifecycle');
const DISPOSE = '$dispose';
const AUTOLOAD = '$autoload';
const INJECTOR = '$injector';
const INSTANCE = '$instance';
const SILO_CONTEXT = '$siloContext';
const FATAL_ERROR = '$fatalError';
const E_BAD_INITIALIZER_TYPE = 'E_BAD_INITIALIZER_TYPE';
const E_BAD_AUTOLOADED_INITIALIZER = 'E_BAD_AUTOLOADED_INITIALIZER';
const E_BAD_AUTOLOADER = 'E_BAD_AUTOLOADER';
const E_AUTOLOADED_INITIALIZER_MISMATCH = 'E_AUTOLOADED_INITIALIZER_MISMATCH';
const E_UNMATCHED_DEPENDENCY = 'E_UNMATCHED_DEPENDENCY';
const E_CIRCULAR_DEPENDENCY = 'E_CIRCULAR_DEPENDENCY';
const E_BAD_INITIALIZER = 'E_BAD_INITIALIZER';
const E_ANONYMOUS_ANALYZER = 'E_ANONYMOUS_ANALYZER';
const E_BAD_SERVICE_PROVIDER = 'E_BAD_SERVICE_PROVIDER';
const E_BAD_SERVICE_PROMISE = 'E_BAD_SERVICE_PROMISE';
const E_INSTANCE_DESTROYED = 'E_INSTANCE_DESTROYED';
const E_AUTOLOADER_DYNAMIC_DEPENDENCY = 'E_AUTOLOADER_DYNAMIC_DEPENDENCY';
const E_BAD_CLASS = 'E_BAD_CLASS';
const E_UNDEFINED_CONSTANT_INITIALIZER = 'E_UNDEFINED_CONSTANT_INITIALIZER';
const E_BAD_VALUED_NON_CONSTANT_INITIALIZER = 'E_BAD_VALUED_NON_CONSTANT_INITIALIZER';

class Knifecycle {
  constructor() {
    _defineProperty(this, "_silosCounter", void 0);

    _defineProperty(this, "_silosContexts", void 0);

    _defineProperty(this, "_initializers", void 0);

    _defineProperty(this, "_initializerResolvers", void 0);

    _defineProperty(this, "_singletonsServicesHandles", void 0);

    _defineProperty(this, "_singletonsServicesDescriptors", void 0);

    _defineProperty(this, "_singletonsServicesShutdownsPromises", void 0);

    _defineProperty(this, "shutdownPromise", void 0);

    this._silosCounter = 0;
    this._silosContexts = new Set();
    this._initializers = new Map();
    this._initializerResolvers = new Map();
    this._singletonsServicesHandles = new Map();
    this._singletonsServicesDescriptors = new Map();
    this._singletonsServicesShutdownsPromises = new Map();
    this.register(constant(INSTANCE, this));
    const initInjectorProvider = initializer({
      name: INJECTOR,
      type: 'provider',
      inject: [SILO_CONTEXT],
      singleton: false
    }, async ({
      $siloContext
    }) => ({
      service: async (dependenciesDeclarations) => _buildFinalHash(await this._initializeDependencies($siloContext, $siloContext.name, dependenciesDeclarations, {
        injectorContext: true,
        autoloading: false
      }), dependenciesDeclarations)
    }));
    this.register(initInjectorProvider);
  }

  register(initializer) {
    if (this.shutdownPromise) {
      throw new YError(E_INSTANCE_DESTROYED);
    }

    unwrapInitializerProperties(initializer);

    if (initializer[SPECIAL_PROPS.TYPE] === 'constant') {
      const value = initializer[SPECIAL_PROPS.VALUE];

      if ('undefined' === typeof value) {
        throw new YError(E_UNDEFINED_CONSTANT_INITIALIZER, initializer[SPECIAL_PROPS.NAME]);
      }

      initializer = provider(async () => ({
        service: value
      }), initializer[SPECIAL_PROPS.NAME], [], true);
      initializer[SPECIAL_PROPS.VALUE] = value;
      initializer[SPECIAL_PROPS.TYPE] = 'constant';
    } else if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {
      throw new YError(E_BAD_VALUED_NON_CONSTANT_INITIALIZER, initializer[SPECIAL_PROPS.NAME]);
    }

    if ('service' === initializer[SPECIAL_PROPS.TYPE]) {
      initializer = reuseSpecialProps(initializer, serviceAdapter.bind(null, initializer[SPECIAL_PROPS.NAME], initializer));
      initializer[SPECIAL_PROPS.TYPE] = 'provider';
    }

    const initializerDependsOfItself = initializer[SPECIAL_PROPS.INJECT].map(_pickServiceNameFromDeclaration).includes(initializer[SPECIAL_PROPS.NAME]);

    if (initializerDependsOfItself) {
      throw new YError(E_CIRCULAR_DEPENDENCY, initializer[SPECIAL_PROPS.NAME]);
    }

    initializer[SPECIAL_PROPS.INJECT].forEach(dependencyDeclaration => {
      this._lookupCircularDependencies(initializer[SPECIAL_PROPS.NAME], dependencyDeclaration);
    });

    if (this._initializers.has(initializer[SPECIAL_PROPS.NAME])) {
      const initializedAsSingleton = this._singletonsServicesHandles.has(initializer[SPECIAL_PROPS.NAME]) && this._singletonsServicesDescriptors.has(initializer[SPECIAL_PROPS.NAME]) && !this._singletonsServicesDescriptors.get(initializer[SPECIAL_PROPS.NAME]).preloaded;
      const initializedAsInstance = [...this._silosContexts.values()].some(siloContext => siloContext.servicesSequence.some(sequence => sequence.includes(initializer[SPECIAL_PROPS.NAME])));

      if (initializedAsSingleton || initializedAsInstance) {
        throw new YError('E_INITIALIZER_ALREADY_INSTANCIATED', initializer[SPECIAL_PROPS.NAME]);
      }

      debug(`'Overridden an initializer: ${initializer[SPECIAL_PROPS.NAME]}`);
    } else {
      debug(`Registered an initializer: ${initializer[SPECIAL_PROPS.NAME]}`);
    }

    if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {
      const handlesSet = new Set();

      this._singletonsServicesHandles.set(initializer[SPECIAL_PROPS.NAME], handlesSet);

      this._singletonsServicesDescriptors.set(initializer[SPECIAL_PROPS.NAME], {
        preloaded: true,
        promise: initializer()
      });
    }

    this._initializers.set(initializer[SPECIAL_PROPS.NAME], initializer);

    return this;
  }

  _lookupCircularDependencies(rootServiceName, dependencyDeclaration, declarationsStacks = []) {
    const serviceName = _pickServiceNameFromDeclaration(dependencyDeclaration);

    const dependencyProvider = this._initializers.get(serviceName);

    if (!dependencyProvider) {
      return;
    }

    declarationsStacks = declarationsStacks.concat(dependencyDeclaration);
    dependencyProvider[SPECIAL_PROPS.INJECT].forEach(childDependencyDeclaration => {
      const childServiceName = _pickServiceNameFromDeclaration(childDependencyDeclaration);

      if (rootServiceName === childServiceName) {
        throw new YError(E_CIRCULAR_DEPENDENCY, ...[rootServiceName].concat(declarationsStacks).concat(childDependencyDeclaration));
      }

      this._lookupCircularDependencies(rootServiceName, childDependencyDeclaration, declarationsStacks);
    });
  }

  toMermaidGraph({
    shapes = [],
    styles = [],
    classes = {}
  } = {
    shapes: [],
    styles: [],
    classes: {}
  }) {
    const servicesProviders = this._initializers;
    const links = Array.from(servicesProviders.keys()).filter(provider => !provider.startsWith('$')).reduce((links, serviceName) => {
      const serviceProvider = servicesProviders.get(serviceName);

      if (!serviceProvider[SPECIAL_PROPS.INJECT].length) {
        return links;
      }

      return links.concat(serviceProvider[SPECIAL_PROPS.INJECT].map(dependencyDeclaration => {
        const dependedServiceName = _pickServiceNameFromDeclaration(dependencyDeclaration);

        return {
          serviceName,
          dependedServiceName
        };
      }));
    }, []);

    const classesApplications = _applyClasses(classes, styles, links);

    if (!links.length) {
      return '';
    }

    return ['graph TD'].concat(links.map(({
      serviceName,
      dependedServiceName
    }) => `  ${_applyShapes(shapes, serviceName) || serviceName}-->${_applyShapes(shapes, dependedServiceName) || dependedServiceName}`)).concat(Object.keys(classes).map(className => `  classDef ${className} ${classes[className]}`)).concat(Object.keys(classesApplications).map(serviceName => `  class ${serviceName} ${classesApplications[serviceName]};`)).join('\n');
  }

  async run(dependenciesDeclarations) {
    const _this = this;

    const internalDependencies = [...new Set(dependenciesDeclarations.concat(DISPOSE))];
    const siloContext = {
      name: `silo-${this._silosCounter++}`,
      servicesDescriptors: new Map(),
      servicesSequence: [],
      servicesShutdownsPromises: new Map(),
      errorsPromises: []
    };

    if (this.shutdownPromise) {
      throw new YError(E_INSTANCE_DESTROYED);
    }

    siloContext.servicesDescriptors.set(FATAL_ERROR, Promise.resolve({
      service: {
        promise: new Promise((resolve, reject) => {
          siloContext.throwFatalError = err => {
            debug('Handled a fatal error', err);
            reject(err);
          };
        })
      }
    }));
    siloContext.servicesDescriptors.set(SILO_CONTEXT, Promise.resolve({
      service: siloContext
    }));
    siloContext.servicesDescriptors.set(DISPOSE, Promise.resolve({
      service: async () => {
        siloContext.shutdownPromise = siloContext.shutdownPromise || _shutdownNextServices(siloContext.servicesSequence);
        debug('Shutting down services');
        await siloContext.shutdownPromise;

        this._silosContexts.delete(siloContext);

        async function _shutdownNextServices(reversedServiceSequence) {
          if (0 === reversedServiceSequence.length) {
            return;
          }

          await Promise.all(reversedServiceSequence.pop().map(async serviceName => {
            const singletonServiceDescriptor = await _this._pickupSingletonServiceDescriptorPromise(serviceName);
            const serviceDescriptor = singletonServiceDescriptor || (await siloContext.servicesDescriptors.get(serviceName));
            let serviceShutdownPromise = _this._singletonsServicesShutdownsPromises.get(serviceName) || siloContext.servicesShutdownsPromises.get(serviceName);

            if (serviceShutdownPromise) {
              debug('Reusing a service shutdown promise:', serviceName);
              return serviceShutdownPromise;
            }

            if (reversedServiceSequence.some(servicesDeclarations => servicesDeclarations.includes(serviceName))) {
              debug('Delaying service shutdown:', serviceName);
              return Promise.resolve();
            }

            if (singletonServiceDescriptor) {
              const handleSet = _this._singletonsServicesHandles.get(serviceName);

              handleSet.delete(siloContext.name);

              if (handleSet.size) {
                debug('Singleton is used elsewhere:', serviceName, handleSet);
                return Promise.resolve();
              }

              _this._singletonsServicesDescriptors.delete(serviceName);
            }

            debug('Shutting down a service:', serviceName);
            serviceShutdownPromise = serviceDescriptor.dispose ? serviceDescriptor.dispose() : Promise.resolve();

            if (singletonServiceDescriptor) {
              _this._singletonsServicesShutdownsPromises.set(serviceName, serviceShutdownPromise);
            }

            siloContext.servicesShutdownsPromises.set(serviceName, serviceShutdownPromise);
            return serviceShutdownPromise;
          }));
          await _shutdownNextServices(reversedServiceSequence);
        }
      },
      dispose: Promise.resolve.bind(Promise)
    }));

    this._silosContexts.add(siloContext);

    const servicesHash = await this._initializeDependencies(siloContext, siloContext.name, internalDependencies, {
      injectorContext: false,
      autoloading: false
    });
    debug('Handling fatal errors:', siloContext.errorsPromises);
    Promise.all(siloContext.errorsPromises).catch(siloContext.throwFatalError);
    return _buildFinalHash(servicesHash, dependenciesDeclarations);
  }

  async destroy() {
    this.shutdownPromise = this.shutdownPromise || Promise.all([...this._silosContexts].map(async siloContext => {
      const $dispose = (await siloContext.servicesDescriptors.get(DISPOSE)).service;
      return $dispose();
    })).then(() => undefined);
    debug('Shutting down Knifecycle instance.');
    return this.shutdownPromise;
  }

  async _getServiceDescriptor(siloContext, serviceName, {
    injectorContext,
    autoloading
  }) {
    let serviceDescriptorPromise = siloContext.servicesDescriptors.get(serviceName);

    if (serviceDescriptorPromise) {
      if (autoloading) {
        debug(`⚠️ - Possible dead lock due to reusing "${serviceName}" from the silo context while autoloading.`);
      }

      return serviceDescriptorPromise;
    }

    const initializer = await this._findInitializer(siloContext, serviceName, {
      injectorContext,
      autoloading
    });
    serviceDescriptorPromise = this._pickupSingletonServiceDescriptorPromise(serviceName);

    if (serviceDescriptorPromise) {
      if (autoloading) {
        debug(`⚠️ - Possible dead lock due to reusing the singleton "${serviceName}" while autoloading.`);
      }

      this._singletonsServicesHandles.get(serviceName).add(siloContext.name);
    } else {
      serviceDescriptorPromise = siloContext.servicesDescriptors.get(serviceName);
    }

    if (serviceDescriptorPromise) {
      return serviceDescriptorPromise;
    }

    if (injectorContext) {
      debug('Warning: Instantiating a new service via the $injector. It may' + ' mean that you no longer need it if your worked around a circular' + ' dependency.');
    }

    serviceDescriptorPromise = this._initializeServiceDescriptor(siloContext, serviceName, initializer, {
      autoloading: autoloading || AUTOLOAD === serviceName,
      injectorContext
    });

    if (initializer[SPECIAL_PROPS.SINGLETON]) {
      const handlesSet = new Set();
      handlesSet.add(siloContext.name);

      this._singletonsServicesHandles.set(serviceName, handlesSet);

      this._singletonsServicesDescriptors.set(serviceName, {
        preloaded: false,
        promise: serviceDescriptorPromise
      });
    } else {
      siloContext.servicesDescriptors.set(serviceName, serviceDescriptorPromise);
    }

    if (AUTOLOAD === serviceName) {
      siloContext.servicesSequence.unshift([AUTOLOAD]);
    }

    return serviceDescriptorPromise;
  }

  async _findInitializer(siloContext, serviceName, {
    injectorContext,
    autoloading
  }) {
    const initializer = this._initializers.get(serviceName);

    if (initializer) {
      return initializer;
    }

    if (autoloading) {
      throw new YError(E_AUTOLOADER_DYNAMIC_DEPENDENCY, serviceName);
    }

    debug('No service provider:', serviceName);

    let initializerPromise = this._initializerResolvers.get(serviceName);

    if (initializerPromise) {
      return await initializerPromise;
    }

    initializerPromise = (async () => {
      if (!this._initializers.get(AUTOLOAD)) {
        throw new YError(E_UNMATCHED_DEPENDENCY, serviceName);
      }

      debug(`Loading the $autoload service to lookup for: ${serviceName}.`);

      try {
        const autoloadingDescriptor = await this._getServiceDescriptor(siloContext, AUTOLOAD, {
          injectorContext,
          autoloading: true
        });
        const {
          initializer,
          path
        } = await autoloadingDescriptor.service(serviceName);

        if (typeof initializer !== 'function' && (typeof initializer !== 'object' || initializer[SPECIAL_PROPS.TYPE] !== 'constant')) {
          throw new YError(E_BAD_AUTOLOADED_INITIALIZER, serviceName, initializer);
        }

        if (initializer[SPECIAL_PROPS.NAME] !== serviceName) {
          throw new YError(E_AUTOLOADED_INITIALIZER_MISMATCH, serviceName, initializer[SPECIAL_PROPS.NAME]);
        }

        debug(`Loaded the ${serviceName} initializer at path ${path}.`);
        this.register(initializer);

        this._initializerResolvers.delete(serviceName);

        return this._initializers.get(serviceName);
      } catch (err) {
        debug(`Could not load ${serviceName} via the auto loader.`);
        throw err;
      }
    })();

    this._initializerResolvers.set(serviceName, initializerPromise);

    return await initializerPromise;
  }

  _pickupSingletonServiceDescriptorPromise(serviceName) {
    const serviceDescriptor = this._singletonsServicesDescriptors.get(serviceName);

    if (!serviceDescriptor) {
      return;
    }

    serviceDescriptor.preloaded = false;
    return serviceDescriptor.promise;
  }

  async _initializeServiceDescriptor(siloContext, serviceName, initializer, {
    autoloading,
    injectorContext
  }) {
    let serviceDescriptor;
    debug('Initializing a service descriptor:', serviceName);

    try {
      await (this._singletonsServicesShutdownsPromises.get(serviceName) || Promise.resolve());

      this._singletonsServicesShutdownsPromises.delete(serviceName);

      siloContext.servicesShutdownsPromises.delete(serviceName);
      const servicesHash = await this._initializeDependencies(siloContext, serviceName, initializer[SPECIAL_PROPS.INJECT], {
        injectorContext,
        autoloading
      });
      debug('Successfully gathered service dependencies:', serviceName);
      serviceDescriptor = await initializer(initializer[SPECIAL_PROPS.INJECT].reduce((finalHash, dependencyDeclaration) => {
        const {
          serviceName,
          mappedName
        } = parseDependencyDeclaration(dependencyDeclaration);
        finalHash[serviceName] = servicesHash[mappedName];
        return finalHash;
      }, {}));

      if (!serviceDescriptor) {
        debug('Provider did not return a descriptor:', serviceName);
        return Promise.reject(new YError(E_BAD_SERVICE_PROVIDER, serviceName));
      }

      debug('Successfully initialized a service descriptor:', serviceName);

      if (serviceDescriptor.fatalErrorPromise) {
        debug('Registering service descriptor error promise:', serviceName);
        siloContext.errorsPromises.push(serviceDescriptor.fatalErrorPromise);
      }

      siloContext.servicesDescriptors.set(serviceName, Promise.resolve(serviceDescriptor));
    } catch (err) {
      debug('Error initializing a service descriptor:', serviceName, err.stack);

      if (E_UNMATCHED_DEPENDENCY === err.code) {
        throw YError.wrap(err, E_UNMATCHED_DEPENDENCY, ...[serviceName].concat(err.params));
      }

      throw err;
    }

    return serviceDescriptor;
  }

  async _initializeDependencies(siloContext, serviceName, servicesDeclarations, {
    injectorContext = false,
    autoloading = false
  }) {
    debug('Initializing dependencies:', serviceName, servicesDeclarations);
    const servicesDescriptors = await Promise.all(servicesDeclarations.map(async serviceDeclaration => {
      const {
        mappedName,
        optional
      } = parseDependencyDeclaration(serviceDeclaration);

      try {
        const serviceDescriptor = await this._getServiceDescriptor(siloContext, mappedName, {
          injectorContext,
          autoloading
        });
        return serviceDescriptor;
      } catch (err) {
        if (optional && ['E_UNMATCHED_DEPENDENCY', E_AUTOLOADER_DYNAMIC_DEPENDENCY].includes(err.code)) {
          debug('Optional dependency not found:', serviceDeclaration, err.stack);
          return;
        }

        throw err;
      }
    }));
    debug('Initialized dependencies descriptors:', serviceName, servicesDeclarations, servicesDescriptors);
    siloContext.servicesSequence.push(servicesDeclarations.filter((_, index) => servicesDescriptors[index]).map(_pickMappedNameFromDeclaration));
    const services = await Promise.all(servicesDescriptors.map(async serviceDescriptor => {
      if (!serviceDescriptor) {
        return undefined;
      }

      return serviceDescriptor.service;
    }));
    return services.reduce((hash, service, index) => {
      const mappedName = _pickMappedNameFromDeclaration(servicesDeclarations[index]);

      hash[mappedName] = service;
      return hash;
    }, {});
  }

}

export default Knifecycle;
export { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, parseName, Knifecycle, initializer, name, autoName, type, inject, useInject, mergeInject, autoInject, alsoInject, extra, singleton, reuseSpecialProps, wrapInitializer, constant, service, autoService, provider, autoProvider, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties, initInitializerBuilder };

function _pickServiceNameFromDeclaration(dependencyDeclaration) {
  const {
    serviceName
  } = parseDependencyDeclaration(dependencyDeclaration);
  return serviceName;
}

function _pickMappedNameFromDeclaration(dependencyDeclaration) {
  const {
    mappedName
  } = parseDependencyDeclaration(dependencyDeclaration);
  return mappedName;
}

function _applyShapes(shapes, serviceName) {
  return shapes.reduce((shapedService, shape) => {
    if (shapedService) {
      return shapedService;
    }

    const matches = shape.pattern.exec(serviceName);

    if (!matches) {
      return shapedService;
    }

    return shape.template.replace(/\$([0-9])+/g, ($, $1) => matches[parseInt($1, 10)]);
  }, '');
}

function _applyClasses(classes, styles, links) {
  return links.reduce((classesApplications, link) => Object.assign(classesApplications, _applyStyles(classes, styles, link)), {});
}

function _applyStyles(classes, styles, {
  serviceName,
  dependedServiceName
}) {
  return styles.reduce((classesApplications, style) => {
    if (style.pattern.test(serviceName) && !classesApplications[serviceName]) {
      if (!classes[style.className]) {
        throw new YError(E_BAD_CLASS, style.className, serviceName);
      }

      classesApplications[serviceName] = style.className;
    }

    if (style.pattern.test(dependedServiceName) && !classesApplications[dependedServiceName]) {
      if (!classes[style.className]) {
        throw new YError(E_BAD_CLASS, style.className, dependedServiceName);
      }

      classesApplications[dependedServiceName] = style.className;
    }

    return classesApplications;
  }, {});
}

function serviceAdapter(serviceName, initializer, dependenciesHash) {
  const servicePromise = initializer(dependenciesHash);

  if (!servicePromise || !servicePromise.then) {
    throw new YError(E_BAD_SERVICE_PROMISE, serviceName);
  }

  return servicePromise.then(_service_ => ({
    service: _service_
  }));
}

function _buildFinalHash(servicesHash, dependenciesDeclarations) {
  return dependenciesDeclarations.reduce((finalHash, dependencyDeclaration) => {
    const {
      serviceName,
      mappedName
    } = parseDependencyDeclaration(dependencyDeclaration);
    finalHash[serviceName] = servicesHash[mappedName];
    return finalHash;
  }, {});
}
//# sourceMappingURL=index.mjs.map